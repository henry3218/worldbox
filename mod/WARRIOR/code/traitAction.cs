using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ai;
using UnityEngine;
using VideoCopilot.code.utils;
using PeerlessOverpoweringWarrior.code.Config;

namespace PeerlessOverpoweringWarrior.code
{
    internal class traitAction
    {
        public static bool IsWarrior1To12(Actor a)
        {
            for (int i = 1; i <= 12; i++)
            {
                if (a.hasTrait($"Warrior{i}") || a.hasTrait($"Warrior{i}+"))
                {
                    return true;
                }
            }
            return false;
        }
        // 武道境界后缀映射表
        private static readonly Dictionary<string, string> _warriorSuffixMap = new Dictionary<string, string>
{
    {"Warrior1", "锻体"},
    {"Warrior2", "炼骨"},
    {"Warrior3", "通脉"},
    {"Warrior4", "气海"},
    {"Warrior5", "化劲"},
    {"Warrior6", "凝罡"},
    {"Warrior7", "洞虚"},
    {"Warrior8", "劫身"},
    {"Warrior9", "武域"},
    {"Warrior91", "合道"},
    {"Warrior92", "斩我"},
    {"Warrior93", "武极"}
};
        
        // 阵道境界后缀映射表
        private static readonly Dictionary<string, string> _formationSuffixMap = new Dictionary<string, string>
        {
            {"FormationRealm1", "引纹"},
            {"FormationRealm2", "灵纹"},
            {"FormationRealm3", "通地"},
            {"FormationRealm4", "蕴枢"},
            {"FormationRealm5", "规元"},
            {"FormationRealm6", "玄真"}
        };
        
        // 阵道尊号前缀字典
        private static readonly Dictionary<string, string[]> _formationTitlesMap = new Dictionary<string, string[]>
        {
            // 第二境界尊号（蕴枢）
            {"FormationRealm2", new string[] {
                "朱痕客", "丹砂逸士", "墨纹生", "赤笔闲人", "纹线清客", "阵基散人", "石痕居士", "线脚逸民", "符边墨客", "阵芽先生",
                "痕边处士", "简纹子", "墨阵散人", "绕途逸客", "转影居士", "迷踪处士", "回途闲人", "旋途逸士", "幻脚先生", "顽石阵客",
                "碎石散人", "垒土居士", "石基处士", "填石闲人", "土纹逸士", "块石清客", "堆土墨客", "草符逸民", "绳结居士", "茅秆处士",
                "麻线闲人", "草梗逸客", "绳痕先生", "枯柴阵士", "草边散人", "麻筋居士", "苇秆处士", "小阵清客", "微纹逸士", "浅痕闲人",
                "半阵墨客", "微阵处士", "小符先生", "浅脚逸民", "半痕散人", "微纹居士", "小基处士", "网眼清客", "半拦逸士", "细网闲人",
                "拦路墨客", "网边处士", "半网先生", "拦脚散人", "细眼居士", "网痕处士", "简阵逸客", "速布闲人", "快手清客", "简纹处士",
                "速痕墨客", "简步先生", "快笔散人", "速结居士", "巧线逸士", "灵点闲人", "半巧清客", "巧痕墨客", "灵线处士", "巧基先生",
                "半灵散人", "巧符居士", "灵痕处士", "虚影匠者", "微光阵客", "细声逸士", "影边闲人", "微响清客", "光痕墨客", "声绕处士",
                "影脚先生", "微亮散人", "声纹居士", "墨线逸民", "赤痕处士", "石纹清客", "阵脚闲人", "符痕墨客", "线纹先生", "朱墨散人",
                "玄阵枢", "灵图客", "地脉翁", "天纹生", "阵衍士", "玄机子", "域局散人", "合阵客", "凝灵君", "枢机先生",
                "藏山隐", "锁川逸士", "星图翁", "云阵客", "风纹子", "玄局生", "地枢居士", "天网客", "阵心隐", "灵局散人",
                "通幽子", "贯微生", "玄脉翁", "妙阵君", "环枢客", "转境士", "凝局先生", "藏锋隐", "显妙子", "合虚生",
                "地纹君", "天枢客", "阵纬翁", "灵枢士", "玄局隐", "通真子", "契道生", "锁阵君", "开域客", "凝纹先生",
                "隐机翁", "显枢士", "玄图子", "地局生", "天阵君", "灵纬客", "藏局隐", "通玄子", "贯道生", "阵机翁",
                "转枢君", "合纹客", "开枢先生", "隐纹士", "显局子", "玄纬生", "地阵君", "天网翁", "灵机客", "藏枢隐",
                "通妙子", "贯微生", "阵纬君", "转图客", "合枢先生", "隐局士", "显灵子", "玄脉生", "地网君", "天纹翁",
                "灵局客", "藏机隐", "通枢子", "贯真生", "阵图君", "转纹客", "合局先生", "隐纬士", "显玄子", "玄机生",
                "地枢君", "天阵翁", "灵脉客", "藏纹隐", "通局子", "贯道生", "阵枢君", "转纬客", "合灵先生", "隐真士",
                "显枢子", "玄局生", "地阵君", "天枢翁", "灵图客", "藏道隐", "通玄子", "贯枢生", "阵合君", "转真客",
                "丹痕居士", "小纹处士", "浅阵逸客", "微痕闲人", "简符清客", "巧线墨客", "灵基先生", "石阵散人", "草纹居士", "绳痕处士"
            }},
            // 第四境界尊号（蕴枢）
            {"FormationRealm4", new string[] {
                "玄纹织络阵师", "灵枢引脉阵师", "地络牵星阵师", "天痕缀月阵师", "纹转阴阳阵师", "枢定四方阵师", "雾隐千丝阵师", "风缠万缕阵师", "石脉通幽阵师", "水纹映虚阵师",
                "星络缠山阵师", "云纹锁江阵师", "气转乾坤阵师", "痕分晦明阵师", "灵织九域阵师", "玄牵八阵阵师", "地脉承天阵师", "天枢接地阵师", "纹隐锋芒阵师", "枢藏机变阵师",
                "雾锁玄关阵师", "风绕奇门阵师", "石痕记幽阵师", "水络含光阵师", "星枢定厄阵师", "云机转厄阵师", "气分两仪阵师", "痕辨三才阵师", "灵络通微阵师", "玄脉贯幽阵师",
                "地纹承露阵师", "天痕饮光阵师", "纹织虚空阵师", "枢引流霞阵师", "雾隐灵踪阵师", "风牵月影阵师", "石络承风阵师", "水枢含露阵师", "星纹缀斗阵师", "云络缠星阵师",
                "气转灵机阵师", "痕藏妙理阵师", "灵枢定雾阵师", "玄纹锁风阵师", "地枢承雨阵师", "天络含云阵师", "纹分经纬阵师", "枢转晨昏阵师", "雾织轻罗阵师", "风缠细缕阵师",
                "石痕记岁阵师", "水纹载道阵师", "星枢引鹤阵师", "云痕伴月阵师", "气合阴阳阵师", "痕缀乾坤阵师", "灵络牵霞阵师", "玄脉承露阵师", "地纹锁雾阵师", "天枢引风阵师",
                "纹隐山河阵师", "枢藏日月阵师", "雾绕琼枝阵师", "风缠玉蕊阵师", "石络通真阵师", "水枢含妙阵师", "星纹记玄阵师", "云络承真阵师", "气转鸿钧阵师", "痕分混沌阵师",
                "灵枢定水阵师", "玄纹锁石阵师", "地络承星阵师", "天痕缀云阵师", "纹织灵网阵师", "枢引地脉阵师", "雾隐玄关阵师", "风绕妙境阵师", "石痕藏道阵师", "水络含机阵师",
                "星枢定风阵师", "云机转雾阵师", "气分四象阵师", "痕辨五行阵师", "灵络通玄阵师", "玄脉贯真阵师", "地纹承风阵师", "天痕饮露阵师", "纹织虚空阵师", "枢引流泉阵师",
                "雾隐仙踪阵师", "风牵月华阵师", "石络承露阵师", "水枢含光阵师", "星纹缀星阵师", "云络缠斗阵师", "气转灵枢阵师", "痕藏玄机阵师", "灵枢定风阵师", "玄纹锁月阵师"
            }},
            // 第五境界尊号（规元）
            {"FormationRealm5", new string[] {
                "天地枢机大阵师", "日月经纬大阵师", "星轨定元大阵师", "山河契道大阵师", "乾坤织络大阵师", "阴阳化境大阵师", "玄黄枢纽大阵师", "太虚阵图大阵师",
                "鸿蒙衍阵大阵师", "万域阵枢大阵师", "一气归真大阵师", "灵源定界大阵师", "九域合章大阵师", "八荒阵纪大阵师", "六虚织阵大阵师", "五炁统阵大阵师",
                "四象枢机大阵师", "三才定阵大阵师", "两仪化阵大阵师", "太极阵宗大阵师", "道藏阵典大阵师", "法界阵图大阵师", "真境织阵大阵师", "玄道合阵大阵师",
                "灵枢统域大阵师", "天痕定海大阵师", "地脉阵宗大阵师", "星斗阵纪大阵师", "云气开阵大阵师", "风轨定阵大阵师", "水纹合道大阵师", "火炁阵枢大阵师",
                "山骨阵图大阵师", "石魄山典大阵师", "虚空阵纪大阵师", "实境阵枢大阵师", "幻海定阵大阵师", "真源步阵大阵师", "始炁阵宗大阵师", "终道阵典大阵师",
                "生灭枢机大阵师", "枯荣阵纪大阵师", "昼夜合阵大阵师", "晨昏定阵大阵师", "雾隐阵图大阵师", "霞蔚名典大阵师", "雷纹枢机大阵师", "星轨斗宗大阵师",
                "霜华织阵大阵师", "雪韵定阵大阵师", "道枢统阵大阵师", "法枢合阵大阵师", "术枢化阵大阵师", "器枢定阵大阵师", "物枢织阵大阵师", "心枢器宗大阵师",
                "神枢阵典大阵师", "意枢阵纪大阵师", "念枢阵图大阵师", "志枢阵枢大阵师", "无象阵宗大阵师", "无形相典大阵师", "无相定阵大阵师", "无名定阵大阵师",
                "无界阵纪大阵师", "有常阵图大阵师", "有定阵枢大阵师", "有象合阵大阵师", "有形化阵大阵师", "有相织阵大阵师", "独步乾坤大阵师", "孤掌星阵大阵师",
                "独尊阵域大阵师", "独悟阵道大阵师", "独契阵真大阵师", "万法归阵大阵师", "千道合阵大阵师", "百术融阵大阵师", "十境通阵大阵师", "一源衍阵大阵师",
                "太初阵衍大阵师", "太始蕴枢大阵师", "太易阵图大阵师", "太素阵典大阵师", "太极阵纪大阵师", "虚极织阵大阵师", "静笃定阵大阵师", "复命阵宗大阵师",
                "归根阵典大阵师", "自然阵纪大阵师", "混成星图大阵师", "无极阵枢大阵师", "太极合阵大阵师", "皇道阵宗大阵师", "帝境阵典大阵师", "王道开阵大阵师",
                "霸道定阵大阵师", "圣道阵纪大阵师", "贤途阵海大阵师", "道御千阵大阵师"
            }},
            // 第六境界尊号（玄真）
            {"FormationRealm6", new string[] {
                "乾坤经纬定化天师", "日月昭回枢机天师", "星轨周天斡旋天师", "山河脉络含章天师", "鸿蒙初判立极天师", "太虚含象化机天师", "玄黄肇分持纪天师", "阴阳燮理归真天师", "大道衍化自然天师", "九域纲维统御天师",
                "八荒枢纽裁成天师", "六虚经纬安镇天师", "五炁流通化育天师", "四象环周定序天师", "三才合序裁成天师", "两仪交泰枢机天师", "太极含元肇化天师", "真境昭彰显化天师", "玄道通微洞鉴天师", "灵源广润滋育天师",
                "法界纲维统御天师", "道枢经纬昭明天师", "德合无疆普化天师", "理贯三才立极天师", "气转周天斡旋天师", "神凝太虚洞明天师", "意契鸿蒙肇基天师", "念通九域昭化天师", "性合自然归真天师", "命契先天立极天师",
                "无象真机显化天师", "无形妙境昭彰天师", "无相玄机洞鉴天师", "无名真宰裁成天师", "无界纲维统御天师", "有常定序安镇天师", "有象真机显化天师", "有形妙境昭彰天师", "有相玄机洞鉴天师", "有名真宰裁成天师",
                "太初肇判立极天师", "太始流形化育天师", "太易含真显化天师", "太素凝精定序天师", "太极旋机斡旋天师", "虚极静笃归真天师", "静复命根立极天师", "归根复命化育天师", "自然无为显化天师", "混成无极肇基天师",
                "无极含真昭明天师", "皇道经纬统御天师", "帝境纲维裁成天师", "王道涵容普化天师", "霸道斡旋定序天师", "圣道昭彰显化天师", "贤途经纬安镇天师", "真宰斡旋立极天师", "元化流通化育天师", "妙化昭彰显化天师",
                "神化无方普化天师", "气化流行滋育天师", "形化端凝定序天师", "精化凝真立极天师", "气化氤氲肇基天师", "魂御九域昭化天师", "魄统八荒定序天师", "神超太虚洞明天师", "志贯九霄立极天师", "意通微末洞鉴天师",
                "理贯始终裁成天师", "法合先天显化天师", "术通玄妙化育天师", "器载真机昭彰天师", "物含妙理洞鉴天师", "道贯三才统御天师", "德合四象安镇天师", "功被九域普化天师", "业存千古昭明天师", "名传万世显化天师",
                "枢转阴阳化育天师", "机旋日月昭彰天师", "轴运乾坤定序天师", "轮行周天斡旋天师", "纲维宇宙立极天师", "纪理阴阳裁成天师", "绳准天地安镇天师", "权衡造化统御天师", "规矩自然显化天师", "权衡古今昭明天师",
                "掌御星河定轨天师", "裁断阴阳显威天师", "斡旋天地枢机天师", "统御九域镇元天师", "执掌太虚玄机天师", "号令风云变阵天师", "安镇八荒纲维天师", "扭转乾坤定序天师", "驾驭日月昭彰天师", "统摄鸿蒙化育天师",
                "掌控玄黄枢要天师", "裁决大道经纬天师", "主掌自然玄机天师", "统御六虚定纪天师", "执掌五炁流通天师", "安镇四象环周天师", "主掌三才合序天师", "统御两仪交泰天师", "执掌太极含元天师", "安镇真境昭彰天师",
                "主掌玄道通微天师", "统御灵源广润天师", "执掌法界纲维天师", "安镇道枢经纬天师", "主掌德合无疆天师", "统御理贯三才天师", "执掌气转周天天师", "安镇神凝太虚天师", "主掌意契鸿蒙天师", "统御念通九域天师",
                "执掌性合自然天师", "安镇命契先天天师", "主掌无象真机天师", "统御无形妙境天师", "执掌无相玄机天师", "安镇无名真宰天师", "主掌无界纲维天师", "统御有常定序天师", "执掌有象真机天师", "安镇有形妙境天师",
                "主掌太初肇判天师", "统御太始流形天师", "执掌太易含真天师", "安镇太素凝精天师", "主掌太极旋机天师", "统御虚极静笃天师", "执掌静复命根天师", "安镇归根复命天师", "主掌自然无为天师", "统御混成无极天师",
                "执掌无极含真天师", "安镇皇道经纬天师", "主掌帝境纲维天师", "统御王道涵容天师", "执掌霸道斡旋天师", "安镇圣道昭彰天师", "主掌贤途经纬天师", "统御真宰斡旋天师", "执掌元化流通天师", "安镇妙化昭彰天师",
                "主掌神化无方天师", "统御气化流行天师", "执掌形化端凝天师", "安镇精化凝真天师", "主掌气化氤氲天师", "统御魂御九域天师", "执掌魄统八荒天师", "安镇神超太虚天师", "主掌志贯九霄天师", "统御意通微末天师",
                "执掌理贯始终天师", "安镇法合先天天师", "主掌术通玄妙天师", "统御器载真机天师", "执掌物含妙理天师", "安镇道贯三才天师", "主掌德合四象天师", "统御功被九域天师", "执掌业存千古天师", "安镇名传万世天师",
                "主掌枢转阴阳天师", "统御机旋日月天师", "执掌轴运乾坤天师", "安镇轮行周天天师", "主掌纲维宇宙天师", "统御纪理阴阳天师", "执掌绳准天地天师", "安镇权衡造化天师", "主掌规矩自然天师", "统御权衡古今天师",
                "执掌尺度乾坤天师", "安镇范围天地天师", "主掌曲成万物天师", "统御通变古今天师", "执掌会通有无天师", "安镇兼赅内外天师", "主掌统摄阴阳天师", "统御总持造化天师", "执掌苞括宇宙天师", "安镇弥纶天地天师",
                "尺度乾坤化育天师", "范围天地立极天师", "曲成万物普化天师", "通变古今洞鉴天师", "会通有无显化天师", "兼赅内外昭彰天师", "统摄阴阳定序天师", "总持造化立极天师", "苞括宇宙普化天师", "弥纶天地昭明天师"
            }},
        };
        
// 尊号字典（洞虚境、合道境、武极境）
private static readonly Dictionary<string, string[]> _warriorTitlesMap = new Dictionary<string, string[]>
{
    // 洞虚境尊号
    {"Warrior7", new string[] {
        "断贪刀", "斩妄剑", "破嗔掌", "碎痴爪", "焚傲炎","丹霞孟尝", "寒江钓叟", "过山峰", "听涛叟", "追星", "落霞剑客", "判官", "分水刺", "白额虎", "金翅雕", "赤练蛇",
        "铁掌分江", "青城鬼脸", "碧磷毒手", "寒江独钓", "断碑书生", "铁掌震北", "无痕神偷", "白莲圣使", "不动明王", "风雪狂刀", "镇岳神枪", "血手人屠", "千面神捕", "九尾狐", "赤练蛇", "穿山鼠", "笑面虎", "千面客", "睡罗汉", "妙手回春", "漠北苍狼",
        "雁门孤狼", "沧浪铁佛", "金顶飞鹰", "玉笔判官", "千仞毒叟", "泣血南山", "青铜罗汉", "赤风", "雨水真人", "移山力士" , "通臂猿", "画皮师", "胖米勒", "瞎判官", "布衣神相", "铁面无私", "流火将", "华盖君", "云中游",
        "银蛇郎君", "玄冰老怪", "黑木无常", "五岳摧心", "铁锁横江", "棋魔子", "画圣笔仙" , "铁幕游侠", "天机神算" , "铁笔书生", "炽火剑", "寒山长枪" , "慈悲先生", "大漠孤狼", "泣竹郎", "照夜白" , "鱼肠客", "焦尾生" , "焚琴子", "桑落翁", "醉扶疏" , "金错刀", "斩楼兰",
        "紫霄雷手", "无鞘刀", "三更死", "血鹦鹉", "断肠客栈", "辨忠奸", "解千愁", "乘黄", "穷奇" , "乱黑白", "奔日月", "陵鱼姬", "泣珠引", "采薇翁", "击筑客", "知风凉", "几多霜雪", 
        "纸刀", "幽灵箭", "血玲珑", "断弦琴", "黑雪", " 烂柯子", "弈春秋", "请缨使", "砺肝胆", "漱石生", "然藜客", "秦淮影", "破胡尘", "蓟北枪", "灞陵尉", "半梦半醒", "寂言客", 
        "残红泣", "孤灯灭", "空棺客", "寒鸦", "碎梦无痕", "大漠飞沙", "碎骨温柔", "空舟载月", "瘦马驮经", "破钵盛雪", "残灯照影", "断碑刻偈", "惊魂幡", "绝命签", "碎心铃", "裂魂爪", "蚀日幡", 
        "白骨画眉", "冷血追魂", "勾魂引", "醉生梦死", "毒菩萨", "吹角将", "扎草人", "烧丹客", "炼龙虎", "相面客", "镇天元", "走龙蛇", "解牛功", "雕龙手", "挽千帆", "黄金獒",
        "血月孤楼", "哭丧人", "大泼血", "黑水车", "冷血残阳", "紫电青霜", "银鞍照雪", "碧落黄泉", "玄冰烈火", "瀚海孤帆", "幸运小猪", "早说先生", "北极星霜", "似梦中", "忘忧生", 
        "销魂伞", "无鞘剑", "伤心箭", "白骨哀", "血河车", "大魔", "鬼面", "大力掌", "江城开碑手", "黑大虫", "霹雳火", "云中金刚", "追风客", "春予心", "玄门教主", "渡秋河",
        "朝天棍", "碎魂锣", "断肠镖", "噬魂刺", "丧门鼓","垂天剑", "血河剑奴", "生死人屠" , "金乌剑", "圣火王", "沧海王", "清圣医", "万雷手", "九阴灼日", "四象伏魔棍", "翻海龙", "青莲剑", 
        "葬妒绫", "化怨笛", "空欲索", "绝惑瞳", "净疑钟","玉面修罗", "白居士", "篆烟客", "五弦使", "弄宫商", "白泽生", "晓百鬼", "饕餮客", "吞山河", "驺虞刃", "毕方使", "鲲鹏客", "渡沧溟", 
        "撕名帖", "裂冠客", "焚绶者", "碎印人", "折笏手","冰魄寒光", "云台飞絮", "玉箫惊鸿", "幽谷鸣泉", "空山鹤唳", "噬魂长枪", "腐心太岁", "血魔刀客", "铁面人屠", 
        "葬玉匠",  "覆棋生", "裂卷生", "碎镜客", "断弦翁","夜修罗", "催命阎王", "萍踪浪医", "霓裳毒仙", "冰川剑魄", "星海飞槎", "玉弓魅影", "狂刀断月", "长河饮秋",
        "孤峰守夜", "寒潭涤剑", "枯冢悟掌", "残阳淬指", "断崖听刀", "快意恩仇", "鬼手佛心", "惊梦钟", "三台客", "雪原葬枪", "沙海焚弓", "雷池拭戟", "瘴林磨爪", "冰谷炼瞳", "孤星葬剑", "还剑公子","麒麟", "烛龙", 
        "十载面壁", "千日负石", "万里量沙", "百川饮马", "孤星伴鹤", "阴煞炼魂君", "夜行舟", "计都踪", "踏月来", "青棠客", "谢春池", "折柳生", "灞桥别", "白山君", "归墟引路",
        "折梅问禅", "扫叶观道", "斫竹见性", "汲泉明心", "拾薪悟真", "劫数刻舟翁", "铁马冰河", "青锋葬雪", "萍踪侠影", "温柔错", "逆水寒","昆仑柱", "须弥圣僧", "毒蛇王", "巨熊王", 
        "裂帛见血", "碎玉闻声", "焚香知寂", "葬花觉空", "覆水证灭", "醉生笑", "孤鸿影", "枯荷听雨", "笑饮霜", "流萤葬火"
    }},
  
    // 武域境尊号
    {"Warrior9", new string[] {
        "裂江断岳宗师", "穿云贯日宗师", "翻江倒海宗师", "分水劈浪宗师", "裂石崩山宗师", "琴心剑胆宗师", "竹影棋风宗师", "松涛鹤唳宗师", "梅雪诗魂宗师", "云影钟声宗师",
        "罡风扫月宗师", "惊雷裂地宗师", "皓月宗师", "苍日横空宗师", "孤星照野宗师", "烟霞醉客宗师", "星月流辉宗师", "山水清音宗师", "乱神宗师", "三秋宗师",
        "观瀑听涛宗师", "踏雪无痕宗师", "凌云步虚宗师", "定海镇波宗师", "镇岳定山宗师", "金石铿锵宗师", "丝竹雅韵宗师", "不动如山宗师", "论道宗师", "书剑飘零宗师",
        "翻江搅浪宗师", "覆海吞江宗师", "擎山托岳宗师", "裂空穿云宗师", "疾风追电宗师", "诗酒风流宗师", "乾坤宗师", "茶禅宗师", "酒仙诗圣宗师", "剑胆琴心宗师",
        "暴雨宗师", "寒霜宗师", "烈火燎原宗师", "落雷破阵宗师", "苍松宗师", "松风竹节宗师", "梅骨兰魂宗师", "莲影荷香宗师", "云帆月楫宗师", "烟蓑雨笠宗师",
        "翠柏凝霜宗师", "古槐盘根宗师", "绿竹穿云宗师", "红梅傲雪宗师", "破晓宗师", "星斗宗师", "魔天宗师", "无间宗师", "丹青宗师", "金石宗师",
        "惊山宗师", "残灯照夜宗师", "晓月残星宗师", "寒星坠野宗师", "惊鸿宗师", "丝桐遗韵宗师", "竹帛烟霞宗师", "琴书雅趣宗师", "棋酒清欢宗师", "诗画通神宗师",
        "游龙临川宗师", "猛虎断岳宗师", "飞龙穿海宗师", "潜蛟出海宗师", "擎天立地宗师", "书画同源宗师", "茶酒论交宗师", "琴剑飘零宗师", "诗酒逍遥宗师", "破风宗师",
        "立地生根宗师", "横江锁浪宗师", "越海翻山宗师", "跨海登舟宗师", "掠影宗师", "茶烟琴韵宗师", "酒旗风暖宗师", "剑影刀光宗师", "诗心剑气宗师", "松月山房宗师",
        "裂石分金宗师", "崩山宗师", "断江截流宗师", "破空裂云宗师", "流云舒卷宗师", "梅雪宗师", "竹雨松风宗师", "茶烟梧月宗师", "箫心合抱宗师", "剑胆双清宗师",
        "飞絮宗师", "飘雪漫空宗师", "落英宗师", "疾风宗师", "玄冰宗师", "松风水月宗师", "烟霞天然宗师", "如云宗师", "琴骨剑心宗师", "同春宗师",
        "赤焰焚天宗师", "青木参天宗师", "黑金裂石宗师", "白水滔天宗师", "孤峰独峙宗师", "竹兰共雅宗师", "菊梅同香宗师", "云客宗师", "星槎月楫宗师", "山灵水韵宗师",
        "藏龙宗师", "大漠烈阳宗师", "瀚海惊涛宗师", "旭日宗师", "松风静听宗师", "剑舞霜华宗师", "红叶闲吟宗师", "青山宗师", "茶烹白雪宗师", "剑倚崆峒宗师",
        "孤月悬空宗师", "寒星宗师", "朗日高悬宗师", "疏星朗月宗师", "酒饮黄花宗师", "棋敲竹露宗师", "书枕松云宗师", "剑横秋水宗师", "琴弹夜月宗师",
        "裂金断铁宗师", "断铁分金宗师", "破玉裂琼宗师", "碎琼乱玉宗师", "迎风逆浪宗师", "诗赋春风宗师", "画染秋云宗师", "茶烹碧涧宗师", "兴逸宗师", "势雄宗师",
        "逆浪行舟宗师", "顶雪踏霜宗师", "冒雨披蓑宗师", "踏霜破冰宗师", "静心守一宗师", "书临青史宗师", "剑倚苍岩宗师", "流泉韵雅宗师", "落照神闲宗师", "烟霞兴畅宗师",
        "剑鸣宗师", "会元宗师", "守意如钢宗师", "存真抱朴宗师", "明心见性宗师", "不迷宗师", "棋斗机锋宗师", "书观今古宗师", "剑荡尘氛宗师","星辰象伟宗师",
        "见性成佛宗师", "悟道参玄宗师", "证理修真宗师", "归真返璞宗师", "撼山动地宗师", "韵正宗师", "画山摹水宗师", "龙胆宗师", "寒冽明镜宗师","云霞色艳宗师",
        "震岳摇川宗师", "动川惊海宗师", "摇海翻江宗师", "惊涛宗师", "穿云破雾宗师", "兵戈势险宗师", "书藏今古宗师", "剑扫妖氛宗师", "琴雅神怡宗师", "诗彩情豪宗师",
        "贯日凌云宗师", "追星逐月宗师", "逐月追星宗师", "揽星摘月宗师", "劈风斩浪宗师", "画染烟岚宗师", "酒泛味醇宗师", "心平宗师", "春秋志远宗师", "潇湘韵远宗师", 
        "斩浪截江宗师", "截江断流宗师", "断河裂岸宗师", "裂涛排浪宗师", "乘风破浪宗师", "剑舞气壮宗师", "格妙宗师", "玉雨玄露宗师",
        "狱罡武王", "战魄武王", "焚劫武王", "镇虚武王", "碎魂武王", "战宇武王", "炼狱武王", "狱灭武王", "罡破武王", "墟陨武王", "陨道武王", "寂灭武王", "劫宇武王", "战虚武王", "焚道武王",
        "镇劫武王", "戮罡武王", "碎战武王", "炼墟武王", "狱神武王", "罡陨武王", "武焚武王", "墟战武王", "战劫武王", "破神武王", "破穹刀王", "焚劫剑王", "镇狱枪王", "碎星拳王", "陨神戟王",
        "戮虚弓王", "战罡锤王", "劫灭刀王", "焚宇剑王", "罡煞枪王", "炼狱戟王", "寂灭弓王", "陨道拳王", "战魄锤王", "焚劫刀王", "碎魂剑王", "墟战枪王", "罡陨戟王", "劫战弓王", "炼神拳王",
        "镇虚锤王", "血魄刀王", "狱罡剑王", "战焚枪王", "破劫戟王", "寂罡弓王", "陨战拳王", "戮道锤王", "罡灭刀王", "劫宇剑王", "炼狱枪王", "战罡戟王", "焚虚弓王", "碎道拳王", "陨劫锤王",
        "罡戮刀王", "劫战剑王", "炼神枪王", "镇狱戟王", "寂灭弓王", "战罡宗师", "焚劫宗师", "陨灭宗师", "破狱宗师", "戮虚宗师", "镇道宗师", "碎宇宗师", "炼神宗师", "寂天宗师", "罡煞宗师",
        "武炼宗师", "墟战宗师", "血魄宗师", "焚轮宗师", "陨神宗师", "狱罡宗师", "战魄宗师", "焚劫宗师", "镇虚宗师", "碎魂宗师", "流云武王", "听风武王", "观山武王", "揽月武王", "镇海武王",
        "栖霞武王", "枕流武王", "漱石武王", "倚松武王", "踏雪武王", "逐日武王", "摘星武王", "惊鸿武王", "游龙武王", "伏虎武王", "鹤唳武王", "猿啼武王", "虎踞武王", "龙蟠武王", "凤栖武王",
        "松涛武王", "竹影武王", "梅骨武王", "莲心武王", "蝉鸣武王", "鹰扬武王", "鹏飞武王", "鲸吞武王", "雷音武王", "电曜武王", "八极宗师", "太极宗师", "形意宗师", "八卦宗师", "通背宗师",
        "劈挂宗师", "螳螂宗师", "鹰爪宗师", "谭腿宗师", "洪拳宗师", "咏春宗师", "六合宗师", "燕青宗师", "查拳宗师", "弹腿宗师", "翻山宗师", "地趟宗师", "红拳宗师", "华拳宗师", "蔡李佛宗师",
        "太极剑王", "流云枪王", "听风刀王", "惊雷戟王", "逐电弓王", "分水棍王", "断岳斧王", "碎星锤王", "揽月钩王", "追魂鞭王", "真我武王", "斩妄战王", "焚血霸侯", "罡魄武王", "劫灭战王", 
        "炼狱霸侯", "战魂武王", "血戮战王", "寂灭霸侯", "破劫武王", "陨神战王", "戮心霸侯", "罡煞武王", "焚我战王", "战魄霸侯", "劫真武王", "炼神战王", "血战霸侯", "寂罡武王", "破妄战王", 
        "陨魄霸侯", "戮虚武王", "罡焚战王", "焚魄霸侯", "战劫武王", "劫战战王", "炼罡霸侯", "血戮武王", "寂墟战王", "破道霸侯", "陨战武王", "戮罡霸侯", "罡陨战王", "焚劫武王", "战灭霸侯",
        "劫魄战王", "炼狱武王", "血焚霸侯", "寂劫战王", "破神武王", "陨罡霸侯", "戮战武王", "罡破战王", "焚战霸侯", "战墟武王", "劫罡霸侯", "炼劫战王", "血陨武王", "寂战霸侯", "破罡战王"
    }},

    // 合道境尊号
    {"Warrior91", new string[] {
        "凌云剑尊", "天道执秤尊者", "鸿蒙演法尊者", "太初问玄君", "法则刻篆使", "玉阙听雷尊者", "金庭炼魄大宗师", "瑶台裁云尊", "璇宫执律尊者", "紫府演法大宗师", "丹霄御气尊", "星汉垂地大宗师", "乾坤清气大宗师", "江河行地大宗师",
        "星河炼魄尊", "轮回磨剑尊者", "星河踏浪尊者", "太虚磨剑大宗师", "碧落斩虹尊", "黄泉渡月尊者", "须弥刻篆大宗师", "吞山摘月尊者", "驺虞碾月大宗师", "毕方蒸霞尊", "渡沧溟月大宗师", "法则镂金大宗师", "乾坤刻雪尊",
        "黄庭大宗师", "南华尊者", "干将剑尊", "刑天战尊" , "精卫刀尊", "天照大宗师", "四极天柱尊者", "乾坤镇北尊者", "铁马踏霜尊者", "青锋削月大宗师", "萍踪踩霞尊", "温柔碾雪尊者", "逆水搓冰大宗师", "昆仑磨月尊", "翠竹凌云大宗师",
        "玉壶承露尊者", "金盏倾霞大宗师", "瑶卮盛月尊", "璇奁藏星尊者", "紫匣封云大宗师", "丹炉煅魂尊", "玄门尊者", "十月环天尊者", "黑天大尊", "星曜大宗师", "千秋看客", "青山盘羊尊者", "星空尊者", "逆反先天大宗师", "太虚织霞尊者",
        "太初炼魂使", "乾坤执子尊", "星望大宗师", "玉衡转斗尊者", "金乌衔日大宗师", "玄武镇渊尊者", "青龙擘海大宗师", "白虎啸岳尊","玉衡转斗尊者", "金乌衔日大宗师", "玄武镇渊尊者", "青龙擘海大宗师", "白虎啸岳尊", "翠柏参天大宗师",
        "毒龙尊者", "寒铁龙骑尊者", "碧落剑圣", "朱雀焚虚尊者", "八卦锁云大宗师", "四象炼罡尊者", "五行凝珠大宗师", "七星贯日尊", "玉杖敲云尊者", "金藜照夜大宗师", "瑶笏指辰尊", "璇圭测斗尊者", "紫璋量天大宗师", "丹璧绘辰尊",
        "黄泉尊者", "盘龙大尊", "玄冰炼魂尊者", "赤焰合道大宗师", "苍梧栖鹤尊", "青冥御龙尊者", "丹丘种玉大宗师", "瑶海尊者", "玉斧开天尊者", "金锤锻地大宗师", "瑶凿穿岳尊", "璇锯截江尊者", "紫袍削月大宗师", "丹凿刻星尊", "月涌大江大宗师",
        "五行尊者", "斩龙弈棋客", "春秋刻篆主", "两仪炼魄尊者", "四象磨剑大宗师", "八卦演法尊", "玉笛横秋尊者", "金弦裂帛大宗师", "瑶琴啸风尊", "璇簫唤月尊者", "紫笙吹露大宗师", "丹瑟鸣霜尊", "苍梧揽月尊者", "青冥御龙大宗师", "星河碾玉尊",
        "太岁尊者", "勾魂尊者", "玉辇巡天尊者", "金鞍踏月大宗师", "瑶辔牵星尊", "璇舆渡汉尊者", "紫缰挽日大宗师", "丹毂碾云尊","天风浪浪大宗师", "海山苍苍大宗师", "河岳英灵大宗师", "日月经天大宗师", "大漠孤烟大宗师", "长河落日大宗师",
        "泰阶平秩大宗师", "云雷经纶大宗师", "风霆行健大宗师", "雨露膏泽大宗师", "苍溟吐曜大宗师", "赤县腾龙大宗师", "神州卧虎大宗师", "九域同风大宗师", "剑扫八荒大宗师", "拳镇四溟大宗师", "掌擎日月大宗师", "指裂苍穹大宗师", "星垂平野大宗师",
        "九天揽月大宗师", "四海屠龙大宗师", "气贯长虹大宗师", "势吞寰宇大宗师", "功昭日月大宗师", "松风万古大宗师", "梅月千秋大宗师", "风云际会大宗师", "龙虎风云大宗师", "鹏举九天大宗师", "凤翔千仞大宗师", "龙腾四海大宗师", "红梅傲雪大宗师",
        "鲸吞沧海大宗师", "鳌戴三山大宗师", "星罗棋布大宗师", "云蒸霞蔚大宗师", "浩然正气大宗师", "至大至刚大宗师", "中庸至德大宗师", "中和至道大宗师", "与天地参大宗师", "并日月明大宗师", "垂宪万世大宗师", "立极千秋大宗师", "青松拔地大宗师",
        "玉阙栖鸾尊者", "金庭驻鹤大宗师", "瑶台驯鹿尊", "璇宫饲凤尊者", "紫府育麟大宗师", "丹霄乘龙尊", "玉阶步月尊者", "金殿踏云大宗师", "瑶墀踩霞尊", "璇廊巡斗尊者", "紫庭观辰大宗师", "丹墀望日尊",
        "战罡尊者", "劫焚尊者", "陨灭尊者", "破狱尊者", "焚宇尊者", "戮劫尊者", "镇虚尊者", "碎星尊者", "炼神尊者", "寂天尊者", "罡煞尊者", "武炼尊者", "墟战尊者", "血魄尊者", "焚轮尊者",
        "陨神尊者", "狱罡尊者", "战魄尊者", "焚劫尊者", "镇道尊者", "碎魂尊者", "战宇尊者", "炼狱尊者", "狱灭尊者", "罡破尊者", "墟陨尊者", "陨道尊者", "寂灭尊者", "劫宇尊者", "战虚尊者",
        "焚道尊者", "镇劫尊者", "戮罡尊者", "碎战尊者", "炼墟尊者", "狱神尊者", "罡陨尊者", "武焚尊者", "墟战尊者", "战劫尊者", "破神尊者", "寂罡尊者", "陨战尊者", "焚狱尊者", "镇虚尊者",
        "戮墟尊者", "劫道尊者", "炼灭尊者", "罡焚尊者", "战陨尊者", "碎劫尊者", "狱宇尊者", "武破尊者", "墟罡尊者", "焚战尊者", "寂道尊者", "陨狱尊者", "镇戮尊者", "劫战尊者", "炼罡尊者",
        "狱墟尊者", "碎焚尊者", "战灭尊者", "罡道尊者", "破墟尊者", "寂战尊者", "陨焚尊者", "劫灭尊者", "武罡尊者", "墟宇尊者", "焚陨尊者", "镇战尊者", "戮灭尊者", "炼劫尊者", "狱道尊者",
        "破穹刀尊", "焚劫剑尊", "镇狱枪尊", "碎星拳尊", "陨神戟尊", "戮虚弓尊", "战罡刀尊", "劫灭剑尊", "焚宇枪尊", "罡煞拳尊", "炼狱戟尊", "寂灭弓尊", "陨道刀尊", "战魄剑尊", "焚劫枪尊",
        "碎魂拳尊", "墟战戟尊", "罡陨弓尊", "劫战刀尊", "炼神剑尊", "镇虚枪尊", "血魄拳尊", "狱罡戟尊", "战焚弓尊", "破劫刀尊", "寂罡剑尊", "陨战枪尊", "戮道拳尊", "罡灭戟尊", "劫宇剑尊",
        "阴阳尊者", "两仪尊者", "四象尊者", "八卦尊者", "周天尊者", "混元尊者", "玄黄尊者", "太虚尊者", "鸿蒙尊者", "无极尊者", "太极尊者", "星穹尊者", "寰宇尊者", "天机尊者", "造化尊者",
        "轮回尊者", "寂灭尊者", "涅槃尊者", "紫霄尊者", "青冥尊者", "九幽尊者", "玄冥尊者", "昊天尊者", "后土尊者", "日耀尊者", "月华尊者", "辰宿尊者", "河洛尊者", "坤元尊者", "乾罡尊者",
        "斩虚武尊", "真我战尊", "炼狱尊者", "焚妄尊者", "罡魄武尊", "劫灭尊者", "战魂武尊", "血炼尊者", "寂灭尊者", "破妄尊者", "陨神战尊", "戮心尊者", "罡煞武尊", "焚我尊者", "战魄尊者",
        "劫真武尊", "炼神尊者", "血战尊者", "寂罡战尊", "破劫武尊", "陨魄尊者", "戮虚战尊", "罡焚武尊", "焚魄尊者", "战劫尊者", "劫战武尊", "炼罡战尊", "血戮尊者", "寂墟武尊", "破道尊者",
        "陨战尊者", "戮罡战尊", "罡陨武尊", "焚劫尊者", "战灭尊者", "劫魄武尊", "炼狱战尊", "血焚尊者", "寂劫武尊", "破神尊者", "陨罡尊者", "戮战战尊", "罡破武尊", "焚战尊者", "战墟尊者",
        "劫罡战尊", "炼劫武尊", "血陨尊者", "寂战尊者", "破罡战尊", "陨劫武尊", "戮陨尊者", "罡戮战尊", "焚罡尊者", "战破尊者", "劫破武尊", "炼战战尊", "血劫尊者", "寂罡尊者", "破战武尊"
    }},

    {"Warrior92", new string[] {
        "万象生灭大尊者", "玄黄演道大圣", "太初启明大圣", "混元开天大尊者", "紫微巡斗大尊", "北辰拱极大圣", "九霄扶摇大尊者", "玉清化炁大尊",
        "星汉垂野大圣", "璇玑悬斡大尊", "钧天广乐大圣", "洛书布阵大尊", "纸纳乾坤大尊", "砚吞沧海大圣", "茶煮春秋大尊者", "乾元资始大圣",
        "禹鼎镇渊大圣", "周礼巡方大圣", "书经载道大尊", "礼乐垂世大圣", "剑胆琴心大尊者", "不朽大圣", "熔炉武圣", "气血大圣", "金身武圣", "玄冥大圣",
        "鲲鹏垂天大尊者", "应龙布雨大尊", "烛龙衔曜大圣", "玄龟负图大尊者", "麒麟踏祥大尊", "青鸾裁霞大圣", "饕餮吞虚大尊者", "穷奇裂宇大尊", "龙章凤姿大圣", 
        "白泽通明大圣", "重明破晦大尊者", "毕方焚荒大尊", "夔雷震世大圣", "昆仑镇岳大尊者", "建木通天大尊者", "浩然正气大尊者", "至大至刚大尊", "中庸合道大圣", "冲虚盈昃大尊", 
        "赤霄焚云大尊者", "碧落裁虹大尊", "黄泉渡厄大圣", "青冥御风大尊者", "玄冥凝霜大尊", "赭壤生春大圣", "齐物玄同大尊者", "逍遥无待大尊", "般若观空大圣", "涅槃寂静大尊者", 
        "光阴长河大尊者", "劫波渡尽大尊", "纪元更始大圣", "宿命织网大尊者", "虚空生灭大圣", "刹那永恒大尊者", "须弥纳芥大圣", "春秋秉笔大尊者", "离骚问天大尊", "易传通神大圣", 
        "冲虚盈昃大圣", "太和保合大圣", "乾元资始大尊者", "坤厚载物大圣", "日躔巡天大尊者", "月离毕雨大尊", "辰宿列张大尊者", "虚空生灭大尊者", "书经垂世大尊", "礼乐合和大圣",
        "玄黄演道大尊者", "混元开天大尊", "太初启明大圣", "玉清化炁大尊者", "上清驭雷大尊", "劫波渡尽大圣", "九幽武圣", "天罡大圣", "地煞武圣", "真炎大圣", "寒冰武圣",
        "昆仑截云大圣", "易水淬锋大尊者", "汤谷煮海大尊", "幽都掌夜大圣", "丰沮玉门大尊者", "钟山烛阴大尊", "羽渊藏鳞大圣", "英招巡疆大尊",
        "云汉回枢大圣", "璇玑玉衡大圣", "启明破晓大尊者", "长庚大圣", "景星庆云大尊者", "雷泽埋剑大尊者", "昆仑磨月大尊者", "星宿量天大圣", "归墟纳川大尊者",
        "昆吾铸锋大尊者", "淬星大尊", "赤水沉珠大尊", "弱水载羽大圣", "雷霆大圣", "风雷武圣", "星辰大圣", "日月武圣", "乾坤大圣", "雪境之主",
        "公输造天大圣", "齐物玄同大尊者", "逍遥无待大尊", "岱宗观日大尊者", "阴阳武圣", "混沌大圣", "虚无武圣", "寂灭大圣", "涅槃武圣",
        "北辰拱极大圣", "紫微巡斗大尊者", "九曜悬枢大圣", "荧惑守心大圣", "璇玑悬斡大尊", "辰宿大圣", "启明大尊者", "长庚大尊", "云汉回枢大圣", "天河注海大尊者", "月离毕雨大圣",
        "日躔巡天大圣", "星汉垂野大尊者", "景星庆云大圣", "雷车奔空大尊者", "电索裂宇大尊", "烛龙衔曜大圣", "鲲鹏垂天大尊者", "应龙布雨大尊", "玄龟负图大圣", "麒麟踏祥大尊者", "重明破晦大圣",
        "霁虹贯霄大圣", "玄冥凝霜大尊者", "赭壤生春大圣", "赤霄焚云大尊者", "碧落裁虹大尊", "白泽通明大圣", "饕餮吞虚大尊者", "穷奇裂宇大尊", "毕方焚荒大圣", "夔雷震世大尊者", "朱雀焚虚大圣",
        "黄泉渡厄大圣", "青冥御风大尊者", "玄穹垂象大圣", "混沌开窍大尊者", "鸿蒙吐纳大尊", "玄武镇渊大圣", "青龙擘海大尊者", "白虎啸岳大尊", "精卫填溟大圣", "刑天舞戚大尊者", "羲和驭日大圣",
        "明鬼天志大圣", "尚同节用大圣", "般若观空大尊者", "涅槃寂静大尊", "格物致知大圣", "阴阳燮理大尊", "五行生克大圣", "句芒司春大圣", "禺彊御海大圣", "陆吾守山大尊者", 
        "昆仑镇岳大尊者", "建木通天大尊者", "不周擎柱大尊", "昆仑截云大圣", "开明启扉大圣", "帝江浑沌大尊者", "天吴涌浪大尊", "弇兹锁宙大圣", "强良掣电大尊者", "奢比尸问天大尊",
        "劫波渡尽大圣", "须弥纳芥大尊", "日晷量天大尊者", "月晷测海大圣", "星槎渡汉大圣", "修罗大圣", "神魔武圣", "永恒大圣", "不灭武圣", "玄黄大圣",
        "云笈藏宙大尊者", "玉衡转斗大尊", "金乌衔日大圣", "素娥碾月大尊者", "金蟾吞岁大尊", "羲和驭日大尊者", "蓐收司秋大圣", "句芒掌春大尊者", "玄冥凝冬大圣", "祝融燃夏大圣",
        "星宿海量天大尊者", "雷泽埋剑大尊", "赤水沉珠大圣", "弱水载羽大尊者", "苍梧栖凤大尊", "汤谷煮海大圣", "归墟纳川大尊者", "羽渊藏鳞大尊", "丰沮启扉大圣", "钟山烛阴大尊者", "崆峒问道大尊",
        "紫霄武圣", "青莲大圣", "白虹武圣", "黑煞大圣", "赤炎武圣", "金乌大圣", "玉龙武圣", "麒麟大圣", "凤凰武圣", "龙象大圣", "虎魄武圣", "玄武大圣", "朱雀武圣", "白虎大圣", "青龙武圣",
        "破天大圣", "碎虚武圣", "炼狱大圣", "深渊武圣", "天元大圣", "地极武圣", "太初大圣", "元始武圣", "造化大圣", "轮回武圣", "斩妄圣者", "真我大圣", "焚血圣者", "罡魄大圣", "劫灭圣者",
        "炼狱大圣", "战魂圣者", "血戮大圣", "寂灭圣者", "破劫大圣", "陨神圣者", "戮心大圣", "罡煞圣者", "焚我大圣", "战魄圣者", "劫真大圣", "炼神圣者", "血战大圣", "寂罡圣者", "破妄大圣",
        "陨魄圣者", "戮虚大圣", "罡焚圣者", "焚魄大圣", "战劫圣者", "劫战大圣", "炼罡圣者", "血戮大圣", "寂墟圣者", "破道大圣", "陨战圣者", "戮罡大圣", "罡陨圣者", "焚劫圣者", "战灭大圣",
        "劫魄圣者", "炼狱大圣", "血焚圣者", "寂劫大圣", "破神圣者", "陨罡大圣", "戮战圣者", "罡破大圣", "焚战圣者", "战墟大圣"
    }},
    
    // 武极境尊号
    {"Warrior93", new string[] {
        "武帝", "神武圣尊", "武神", "武祖", "太极阴阳大帝", "光明帝尊", "东王神武圣尊", "太极崩神帝君", "两仪焚界帝", "血海大帝", "绝情断念帝尊", "诛心炼魄圣尊", "幽冥锁魂帝君", "红尘战狂帝", "建木临凡大帝",
        "阎罗大帝", "昆仑血神大帝", "血河弥陀佛主", "绝情帝", "波斯圣帝", "太初道君" , "四象神君", "周天星主", "混沌魔主", "残阳大帝", "昆仑天帝", "沧海龙皇", "焚天炎阳帝君", "炼道至尊", "焚轮至尊",
        "血海慈航大帝", "怒涛卷云大帝", "玄铁无常大帝", "青岚帝君", "星河炼界皇", "太初擘地圣尊", "万劫灭世主", "天道碎碑君", "怒涛卷岳大帝", "玄铁锻骨帝尊", "青岚裁风圣尊", "沧海破岳帝君", "焚天裂日帝",
        "绝灭帝君", "沧海龙皇", "九天真尊", "鸿蒙锻星帝", "虚无裂宇皇", "轮回葬日帝尊", "因果焚天主", "劫数崩岳帝君", "雷霆裂天大帝", "乾坤锻体帝尊", "鸿蒙碎岳圣尊", "太初炼魂帝君", "星河崩刃帝", "天武大帝", "虚无灭神帝尊", "星河擘日帝君", "鸿蒙碎穹帝",
        "梼杌大帝", "狻猊大帝", "青虹剑帝", "太极屠神帝", "两仪灭仙皇", "四象崩宙帝尊", "八卦碎虚主", "混沌炼世帝君", "赤焰焚天大帝", "玄冰裂地帝尊", "紫电裁云圣尊", "青霜斩月帝君", "黄泉渡魂帝", "灭世焚天大帝", "钧天抚琴帝尊", "紫微大帝", "万劫圣尊", "宿命帝君",
        "天武圣帝", "日月分错大帝", "北海大帝", "星河大帝", "惊鸿刀帝", "蚩尤大帝", "天道炼星帝", "混沌擘宇皇", "两仪帝尊", "四象焚穹主", "葬世帝君", "九阳焚宇大帝", "化血弑神帝尊", "三千荡魔圣尊", "万法帝君", "劫火擘日帝",
        "红尘大帝", "阎罗帝君", "混沌云都大帝", "绝情大帝", "诛心大帝", "幽冥大帝", "血河大帝", "至上光明大尊", "罗浮剑主", "饕餮吞武大帝", "梼杌裂甲帝尊", "狻猊镇岳圣尊", "白泽演武帝君", "鲲鹏搏空帝", "葬星炼武大帝", "铸戟凌尘帝尊", "燃燧开天圣尊", "垂天镇岳帝君",
        "天刑劫帝", "人屠刀帝", "周天星主", "葬帝", "裂云大帝", "覆海大帝", "太初锻界大帝", "虚无屠世神皇", "法则崩宙圣尊", "星河灭世主", "鸿蒙碎天帝君", "九天真武大帝", "万劫锻魂帝尊", "宿命裂星圣尊", "劫数葬月帝君", "因果大帝",
        "化血神君", "三千荡神帝", "万法焚宇皇", "宿命大帝尊", "劫火裂穹圣主", "天道葬世帝君", "三千碎神帝", "万法葬宇皇", "劫火擘日帝尊", "宿命炼穹圣主", "玄冥镇北大帝", "断岳帝尊", "龙象般若圣尊", "摘日填渊帝君", "天命大帝",
        "玄冥大帝", "断岳刀皇", "龙象般若大帝", "天命执棋大帝", "芥子须弥未来佛", "凌波剑帝", "北冥剑帝", "紫微星主", "东王公", "光明圣王", "太极阴阳大帝", "苍梧神主", "修罗大帝", "四象裂星尊", "八卦锻天主", "混沌大帝君",
        "灭世大帝", "钧天抚琴尊圣", "紫微剑仙", "万劫锻神帝", "宿命裂界皇","太韶乐圣", "北斗武圣", "三千道纹帝君", "万法归一君", "虚无抱一大天尊", "天道垂钓主", "鸿蒙磨剑道尊",  "劫数碎星尊", "因果炼天主", "太初崩宙君", "太极崩神帝", "两仪焚界皇", 
        "吞日武尊", "听雷渊主", "拭剑云帝", "大黑天", "虚无灭神帝", "法则葬宇皇", "星河擘日帝尊", "鸿蒙碎穹武主", "天道炼世帝君", "玉霄摘星圣尊", "玄霜炼魄大帝", "金阙驭龙帝君", "紫府焚天帝尊", "瑶台煮海圣尊", "战宇武神", 
        "葬星潭皇", "铸戟潮神大帝", "燃燧圣尊", "垂天冥君", "种莲墟圣", "四象裂星大帝", "八卦锻天圣尊", "混沌灭宙帝君", "九霄玄上帝尊", "无量神武大帝", "狠人大帝", "无始大帝", "虚空大帝", "恒宇大帝", "青帝", "寂武大帝",
        "西皇", "太阴人皇", "太阳圣皇", "九黎大帝", "伏羲大帝", "阿弥陀佛大帝", "乱古大帝",  "斗战圣皇", "麒麟古皇", "血凰古皇", "万龙皇", "神皇", "不死天皇", "帝尊","碎虚大帝", "破宇大帝", "断空大帝", "灭劫大帝", "葬界大帝",
        "镇狱大帝", "执幽大帝", "掌轮大帝", "武极大帝", "战天大帝", "绝武大帝", "不灭大帝", "永劫大帝", "亘古大帝", "混沌大帝", "鸿蒙大帝", "太初大帝", "破宇帝", "断空帝", "灭劫帝", "葬界帝", "镇狱帝", "墟宇大帝", "寂罡武神",
        "执幽帝", "掌轮帝", "战天帝", "绝武帝", "不灭帝", "永劫帝", "亘古帝", "混沌帝", "鸿蒙帝", "太初帝", "元始帝", "碎虚圣皇", "破宇圣皇", "断空圣皇", "灭劫圣皇", "葬界圣皇", "镇狱圣皇", "执幽圣皇", "掌轮圣皇", "武极圣皇", "战天圣皇",
        "绝武圣皇", "不灭圣皇", "永劫圣皇", "亘古圣皇", "混沌圣皇", "鸿蒙圣皇", "太初圣皇", "灵宝天尊", "道德天尊", "元始天尊", "逍遥天尊", "长生天尊", "寂灭天尊", "渡劫天尊", "羽化大帝", "道衍大帝", "星河大帝", "武陨大帝", 
        "劫焱武帝", "战罡武神", "陨墟至尊", "焚宇道主", "戮劫武帝", "劫灭大帝", "战墟大帝", "罡极大帝", "狱神大帝", "荒宇大帝", "武寰大帝", "碎虚大帝", "镇轮大帝", "焚天大帝", "陨星大帝", "破穹大帝", "戮神大帝", "战魄武神", 
        "陨劫大帝", "焚宇大帝", "碎道大帝", "镇狱大帝", "战极大帝", "罡武大帝", "劫武大帝", "荒战大帝", "神罡大帝", "灭道大帝", "陨墟大帝", "碎宇大帝", "焚劫大帝", "镇荒大帝", "战狱大帝", "极戮大帝", "罡灭大帝", "劫神大帝",
        "灭罡大帝", "碎战大帝", "焚武大帝", "狱劫大帝", "荒戮大帝", "神墟大帝", "陨武大帝", "罡宇大帝", "劫灭武帝", "战墟武帝", "镇狱武神", "碎星至尊", "炼神道主", "寂天武帝", "破道武神", "罡煞至尊", "武灭道主", "墟神武帝",
        "陨神道主", "狱劫武帝", "罡宇武神", "碎道至尊", "炼狱道主", "战魂武帝", "焚虚武神", "镇宇至尊", "戮道道主", "劫神武帝", "罡战武神", "陨灭至尊", "寂墟道主", "破罡武帝", "武戮武神", "焚劫至尊", "镇神道主", "碎魂武帝", 
        "狱灭道主", "罡破武帝", "墟战武神", "陨道至尊", "寂灭道主", "劫宇武帝", "战虚武神", "焚道至尊", "镇劫道主", "戮罡武帝", "碎战武神", "炼墟至尊", "狱神道主", "罡陨武帝", "武焚武神", "墟灭至尊", "战劫道主", "破神武帝", 
        "焚狱道主", "镇虚武帝", "戮墟武神", "劫道至尊", "炼灭道主", "罡焚武帝", "战陨武神", "碎劫至尊", "狱宇道主", "武破武帝", "墟罡武神", "焚战至尊", "寂道道主", "陨狱武帝", "镇戮武神", "劫战至尊", "炼罡道主", "狱墟武帝",
        "罡道道主", "破墟武帝", "寂战武神", "陨焚至尊", "劫灭道主", "武罡武帝", "墟宇武神", "焚陨至尊", "镇战道主", "戮灭武帝", "炼劫武神", "狱道至尊", "碎寂道主", "罡戮武帝", "战焚武神", "碎焚武神", "战灭至尊", "陨战至尊",
        "陨罡至尊", "寂劫道主", "破狱武帝", "墟灭武神", "焚戮至尊", "劫罡道主", "镇陨武帝", "战道武神", "炼战至尊", "狱焚道主", "炼狱大帝", "战罡大帝"
    }}
};
// 更新武道境界名称后缀
        private static void UpdateNameSuffix(Actor actor, string newTrait)
        {
            if (_warriorSuffixMap.TryGetValue(newTrait, out string suffix))
            {
                string currentName = actor.getName();
                
                // 优化：检查当前名称是否已经包含正确的后缀，如果是，则跳过更新
                int lastDashIndex = currentName.LastIndexOf('-');
                if (lastDashIndex >= 0)
                {
                    string currentSuffix = currentName.Substring(lastDashIndex + 1);
                    if (currentSuffix.Equals(suffix, StringComparison.Ordinal))
                    {
                        return; // 名称已经包含正确的后缀，无需更新
                    }
                    
                    // 分离基础名称（包括尊号）和旧境界后缀
                    string basePart = currentName.Substring(0, lastDashIndex).Trim();
                    
                    // 设置新名称：基础名称 + 新境界后缀
                    actor.setName(basePart + "-" + suffix);
                }
                else
                {
                    // 没有旧后缀，直接添加新后缀
                    actor.setName(currentName + "-" + suffix);
                }
            }
        }
        
        // 辅助方法：从角色特质中获取正确的阵道后缀和武道后缀
        private static void GetSuffixesFromTraits(Actor actor, out string formationSuffix, out string warriorSuffix)
        {
            formationSuffix = "";
            warriorSuffix = "";
            
            // 遍历所有可能的阵道后缀，检查角色是否有对应的特质
            foreach (var kvp in _formationSuffixMap)
            {
                if (actor.hasTrait(kvp.Key))
                {
                    formationSuffix = kvp.Value;
                    break;
                }
            }
            
            // 遍历所有可能的武道后缀，检查角色是否有对应的特质
            foreach (var kvp in _warriorSuffixMap)
            {
                if (actor.hasTrait(kvp.Key))
                {
                    warriorSuffix = kvp.Value;
                    break;
                }
            }
        }
        
        // 更新阵道境界名称后缀
        private static void UpdateFormationNameSuffix(Actor actor, string newTrait)
        {
            if (_formationSuffixMap.TryGetValue(newTrait, out string suffix))
            {
                string currentName = actor.getName();
                
                // 1. 提取真正的基础名称（包含尊号但不包含后缀）
                string baseName = ExtractTrueBaseName(currentName);
                
                // 2. 使用辅助方法从角色特质中获取正确的后缀
                string formationSuffix, warriorSuffix;
                GetSuffixesFromTraits(actor, out formationSuffix, out warriorSuffix);
                
                // 3. 构建新名称
                // 先检查是否有尊号前缀（阵道尊号使用方括号格式）
                string fullBaseName = currentName;
                if (currentName.StartsWith("【") && currentName.Contains("】"))
                {
                    // 保留阵道尊号格式
                    int endBracketIndex = currentName.IndexOf("】");
                    if (endBracketIndex > 0)
                    {
                        string title = currentName.Substring(0, endBracketIndex + 1);
                        fullBaseName = title + baseName;
                    }
                }
                else
                {
                    // 检查是否有武道尊号（破折号格式）
                    int firstDashIndex = currentName.IndexOf('-');
                    if (firstDashIndex > 0)
                    {
                        string potentialTitle = currentName.Substring(0, firstDashIndex).Trim();
                        if (potentialTitle.Length > 0 && potentialTitle.Length <= 4 && System.Text.RegularExpressions.Regex.IsMatch(potentialTitle, "^[\u4e00-\u9fa5]+") && !_warriorSuffixMap.Values.Contains(potentialTitle))
                        {
                            // 看起来像武道尊号，保留格式
                            fullBaseName = potentialTitle + "-" + baseName;
                        }
                        else
                        {
                            // 不包含尊号，直接使用基础名称
                            fullBaseName = baseName;
                        }
                    }
                    else
                    {
                        fullBaseName = baseName;
                    }
                }
                
                // 4. 添加阵道后缀和武道后缀
                string newName = fullBaseName;
                
                // 使用中文间隔号分隔阵道后缀
                newName += "·" + formationSuffix;
                
                // 添加武道后缀（如果有）
                if (!string.IsNullOrEmpty(warriorSuffix))
                {
                    newName += "-" + warriorSuffix;
                }
                
                actor.setName(newName);
            }
        }

private static void ApplyFormationTitle(Actor actor, string newTrait)
        {
            if (_formationTitlesMap.TryGetValue(newTrait, out string[] titles))
            {
                string currentName = actor.getName();
                
                // 1. 提取角色的真正基础名称（不包含任何尊号和后缀）
                string baseName = ExtractTrueBaseName(currentName);
                
                // 2. 使用辅助方法从角色特质中获取正确的后缀
                string formationSuffix, warriorSuffix;
                GetSuffixesFromTraits(actor, out formationSuffix, out warriorSuffix);
                
                // 3. 随机选择新阵道尊号
                string title = titles[UnityEngine.Random.Range(0, titles.Length)];
                
                // 4. 构建新名称：阵道尊号[XXX] + 基础名称 + 阵道后缀 + 武道后缀
                // 使用方括号格式显示阵道尊号，与武道尊号形成明显区分
                string newName = "【" + title + "】" + baseName;
                
                if (!string.IsNullOrEmpty(formationSuffix))
                {
                    // 使用中文间隔号分隔阵道后缀，与武道后缀的破折号区分，更加美观
                    newName += "·" + formationSuffix;
                }
                
                if (!string.IsNullOrEmpty(warriorSuffix))
                {
                    // 保持武道后缀使用破折号
                    newName += "-" + warriorSuffix;
                }
                
                actor.setName(newName);
            }
        }
        
        // GetSuffixesFromTraits方法已在第312行附近定义，删除重复定义
        
        // 辅助方法：提取角色的真正基础名称（去除所有尊号前缀和后缀）
        private static string ExtractTrueBaseName(string currentName)
        {
            string baseName = currentName;
            
            // 1. 先处理后缀部分
            // 获取所有可能的后缀
            List<string> allSuffixes = new List<string>();
            allSuffixes.AddRange(_formationSuffixMap.Values);
            allSuffixes.AddRange(_warriorSuffixMap.Values);
            
            // 循环移除末尾的所有后缀，直到没有后缀为止
            bool suffixRemoved;
            do
            {
                suffixRemoved = false;
                foreach (string suffix in allSuffixes)
                {
                    // 检查破折号格式的后缀
                    if (baseName.EndsWith($"-{suffix}"))
                    {
                        baseName = baseName.Substring(0, baseName.Length - (suffix.Length + 1)).Trim();
                        suffixRemoved = true;
                        break;
                    }
                    // 检查中文间隔号格式的阵道后缀（当前使用格式）
                    else if (baseName.EndsWith($"·{suffix}") && _formationSuffixMap.Values.Contains(suffix))
                    {
                        baseName = baseName.Substring(0, baseName.Length - (suffix.Length + 1)).Trim();
                        suffixRemoved = true;
                        break;
                    }
                }
            } while (suffixRemoved);
            
            // 2. 检查并移除中间的阵道后缀（处理多种格式）
            bool middleSuffixRemoved;
            do
            {
                middleSuffixRemoved = false;
                foreach (string suffix in _formationSuffixMap.Values)
                {
                    // 检查破折号格式的中间后缀
                    if (baseName.Contains($"-{suffix}-"))
                    {
                        string[] parts = baseName.Split(new string[] { $"-{suffix}-" }, StringSplitOptions.None);
                        if (parts.Length >= 1)
                        {
                            baseName = parts[0].Trim();
                        }
                        middleSuffixRemoved = true;
                        break;
                    }
                    // 检查中文间隔号格式的中间后缀（当前使用格式）
                    else if (baseName.Contains($"·{suffix}-"))
                    {
                        string[] parts = baseName.Split(new string[] { $"·{suffix}-" }, StringSplitOptions.None);
                        if (parts.Length >= 1)
                        {
                            baseName = parts[0].Trim();
                        }
                        middleSuffixRemoved = true;
                        break;
                    }
                }
            } while (middleSuffixRemoved);
            
            // 3. 最后移除任何可能的尊号前缀
            // 首先处理阵道尊号的方括号格式 [XXX]
            if (baseName.StartsWith("【") && baseName.Contains("】"))
            {
                int endBracketIndex = baseName.IndexOf("】");
                if (endBracketIndex > 0)
                {
                    baseName = baseName.Substring(endBracketIndex + 1).Trim();
                }
            }
            // 处理间隔号格式（兼容旧数据）
            // 不再直接取间隔号后面的部分作为基础名称，避免错误移除基础名称
            // 同时处理旧格式（破折号）
            else
            {
                int firstDashIndex = baseName.IndexOf('-');
                if (firstDashIndex > 0)
                {
                    // 检查是否是尊号前缀而不是其他后缀
                    // 修改长度限制，支持更长的尊号前缀
                    string potentialTitle = baseName.Substring(0, firstDashIndex).Trim();
                    if (potentialTitle.Length > 0 && potentialTitle.Length <= 8 && System.Text.RegularExpressions.Regex.IsMatch(potentialTitle, "^[\u4e00-\u9fa5]+$"))
                    {
                        // 如果看起来像尊号，提取后半部分作为基础名称
                        baseName = baseName.Substring(firstDashIndex + 1).Trim();
                    }
                }
            }
            
            return baseName;
        }
        
private static void ApplyWarriorTitle(Actor actor, string newTrait)
{
    // 检查角色是否有任何阵道境界特质，如果有则不应用武道尊号
    bool hasFormationRealm = false;
    foreach (string realm in new string[] { "FormationRealm1", "FormationRealm2", "FormationRealm3", "FormationRealm4", "FormationRealm5", "FormationRealm6" })
    {
        if (actor.hasTrait(realm))
        {
            hasFormationRealm = true;
            break;
        }
    }
    
    // 如果角色有阵道境界特质，则不应用武道尊号
    if (hasFormationRealm)
    {
        return;
    }
    
    if (_warriorTitlesMap.TryGetValue(newTrait, out string[] titles))
    {
        string currentName = actor.getName();
        
        // 1. 获取纯净的基础名称
        string baseName = ExtractTrueBaseName(currentName);
        
        // 2. 使用辅助方法从角色特质中获取正确的后缀
        string formationSuffix, warriorSuffix;
        GetSuffixesFromTraits(actor, out formationSuffix, out warriorSuffix);
        
        // 3. 随机选择新尊号
        string title = titles[UnityEngine.Random.Range(0, titles.Length)];
        
        // 4. 构建新名称：新尊号 + 基础名称 + 阵道后缀 + 武道后缀
        // 武道尊号保持使用破折号格式
        string newName = title + "-" + baseName;
        
        if (!string.IsNullOrEmpty(formationSuffix))
        {
            // 使用中文间隔号分隔阵道后缀，与武道后缀的破折号区分，更加美观
            newName += "·" + formationSuffix;
        }
        
        if (!string.IsNullOrEmpty(warriorSuffix))
        {
            newName += "-" + warriorSuffix;
        }
        
        actor.setName(newName);
    }
}

    public static bool SpiritualPlant01_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+5); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant1+"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant1+");
        return true;
    }

    public static bool SpiritualPlant2_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+10); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant2"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant2");
        return true;
    }

    public static bool SpiritualPlant3_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+15); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant3"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant3");
        return true;
    }

    public static bool SpiritualPlant4_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+20); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant4"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant4");
        return true;
    }

    public static bool SpiritualPlant5_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+30); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant5"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant5");
        return true;
    }

    public static bool SpiritualPlant6_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+40); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant6"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant6");
        return true;
    }

    public static bool SpiritualPlant7_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+50); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant7"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant7");
        return true;
    }

    public static bool SpiritualPlant8_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+60); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant8"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant8");
        return true;
    }

    public static bool SpiritualPlant9_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+70); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant9"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant9");
        return true;
    }
    
    // 真罡灵植功能实现 - 低阶真罡灵植
    // 静态缓存 - 真罡灵植配置表
    private static readonly Dictionary<string, int> _trueGangPlantConfig = new Dictionary<string, int>()
    {
        {"TrueGangPlant1", 50},   // 玄罡草
        {"TrueGangPlant2", 100},  // 天罡叶
        {"TrueGangPlant3", 200},  // 真罡花
        {"TrueGangPlant4", 300},  // 地罡根
        {"TrueGangPlant5", 500},  // 雷罡笋
        {"TrueGangPlant6", 800},  // 九霄罡果
        {"TrueGangPlant7", 1200}, // 混沌罡莲
        {"TrueGangPlant8", 2000}, // 太初罡晶
        {"TrueGangPlant9", 3000}  // 武祖罡灵
    };

    // 通用真罡灵植方法，替代之前的9个独立方法
    public static bool ApplyTrueGangPlantEffect(BaseSimObject pTarget, WorldTile pTile = null, string plantTraitId = null)
    {
        if (!pTarget.isActor() || string.IsNullOrEmpty(plantTraitId)) return false;
        
        // 从配置表获取对应真罡值
        if (!_trueGangPlantConfig.TryGetValue(plantTraitId, out int trueGangValue))
            return false;
        
        Actor a = pTarget.a;
        a.ChangeTrueGang(+trueGangValue);
        pTarget.a.removeTrait(plantTraitId); // 移除特质（一次性效果）
        NotificationHelper.ShowTrueGangPlantNotification(a, plantTraitId);
        return true;
    }

    // 保留原有接口以确保兼容性
    public static bool TrueGangPlant1_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant1");
    public static bool TrueGangPlant2_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant2");
    public static bool TrueGangPlant3_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant3");
    public static bool TrueGangPlant4_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant4");
    public static bool TrueGangPlant5_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant5");
    public static bool TrueGangPlant6_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant6");
    public static bool TrueGangPlant7_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant7");
    public static bool TrueGangPlant8_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant8");
    public static bool TrueGangPlant9_Regen(BaseSimObject pTarget, WorldTile pTile = null) => ApplyTrueGangPlantEffect(pTarget, pTile, "TrueGangPlant9");
        
        public static bool SpiritualPlant1_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
        if (!pTarget.isActor()) return false;
        Actor a = pTarget.a;

        // 优先检测最高级根骨（新增真武转世/天生至尊检测）
        string currentAptitude = "";
        if (a.hasTrait("martialAptitude8")) currentAptitude = "martialAptitude8";
        else if (a.hasTrait("martialAptitude7")) currentAptitude = "martialAptitude7";
        else if (a.hasTrait("martialAptitude4")) currentAptitude = "martialAptitude4";
        else if (a.hasTrait("martialAptitude3")) currentAptitude = "martialAptitude3";
        else if (a.hasTrait("martialAptitude2")) currentAptitude = "martialAptitude2";
        else if (a.hasTrait("martialAptitude1")) currentAptitude = "martialAptitude1";

        // 定义进化路径（仅限可进化的根骨）
        Dictionary<string, string> evolutionPath = new Dictionary<string, string>()
        {
            { "martialAptitude1", "martialAptitude2" },
            { "martialAptitude2", "martialAptitude3" },
            { "martialAptitude3", "martialAptitude4" }
        };

        bool isEvolved = false;

        // 处理进化或气血提升
        if (evolutionPath.TryGetValue(currentAptitude, out string newAptitude))
        {
            a.removeTrait(currentAptitude);
            a.addTrait(newAptitude);
            isEvolved = true;
        }
        else if (currentAptitude == "martialAptitude4" || 
                 currentAptitude == "martialAptitude7" || 
                 currentAptitude == "martialAptitude8")
        {
            // 玄玉根骨、真武转世、天生至尊直接提升气血
            int baseValue = 0;
            switch (currentAptitude)
            {
                case "martialAptitude4": baseValue = 900; break;
                case "martialAptitude7": baseValue = 1200; break;
                case "martialAptitude8": baseValue = 1600; break;
            }
            a.ChangeWarrior(baseValue);
            isEvolved = true;
        }

        // 显示通知并移除灵植
        if (isEvolved)
        {
            NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant1");
            pTarget.a.removeTrait("SpiritualPlant1"); // 关键代码：直接移除特质
        }

        return true;
    }
    public static bool SpiritualPlant91_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+80); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant91"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant91");
        return true;
    }

    public static bool SpiritualPlant92_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+90); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant92"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant92");
        return true;
    }

    public static bool SpiritualPlant93_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+100); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant93"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant93");
        return true;
    }

    public static bool SpiritualPlant94_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+200); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant94"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant94");
        return true;
    }

    public static bool SpiritualPlant95_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+300); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant95"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant95");
        return true;
    }

    public static bool SpiritualPlant96_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+400); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant96"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant96");
        return true;
    }

    public static bool SpiritualPlant97_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+500); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant97"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant97");
        return true;
    }

    public static bool SpiritualPlant98_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+1000); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant98"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant98");
        return true;
    }

    public static bool SpiritualPlant99_Regen(BaseSimObject pTarget, WorldTile pTile = null)
    {
        if (!pTarget.isActor()) return false;
    
        Actor a = pTarget.a;
        a.ChangeWarrior(+3000); // 增加5点气血
        pTarget.a.removeTrait("SpiritualPlant99"); // 移除特质（一次性效果）  
        NotificationHelper.ShowSpiritualPlantNotification(a, "SpiritualPlant99");
        return true;
    }

    // 境界与灵植宝药的对应关系
    private static readonly Dictionary<string, string[]> RealmToPlantsMap = new Dictionary<string, string[]>
    {
        // 锻体境 - 基础灵植
        {"Warrior1", new[] {"SpiritualPlant1+", "SpiritualPlant2"}},
        
        // 炼骨境 - 基础灵植
        {"Warrior2", new[] {"SpiritualPlant3", "SpiritualPlant4"}},
        
        // 通脉境 - 基础灵植
        {"Warrior3", new[] {"SpiritualPlant1+", "SpiritualPlant2", "SpiritualPlant3", "SpiritualPlant4"}},
        
        // 气海境 - 进阶灵植
        {"Warrior4", new[] {"SpiritualPlant5", "SpiritualPlant6", "SpiritualPlant7", "SpiritualPlant8", "SpiritualPlant1"}},
        
        // 化劲境 - 高级灵植
        {"Warrior5", new[] {"SpiritualPlant9", "SpiritualPlant91", "SpiritualPlant1"}},
        
        // 凝罡境 (开始有真罡) - 增加各级真罡灵植
        {"Warrior6", new[] {"SpiritualPlant92", "SpiritualPlant93", "TrueGangPlant1", "TrueGangPlant2", "TrueGangPlant3", "TrueGangPlant4", "TrueGangPlant5", "TrueGangPlant6"}},
        
        // 洞虚境 - 增加中高阶真罡灵植
        {"Warrior7", new[] {"SpiritualPlant94", "SpiritualPlant95", "SpiritualPlant1", "TrueGangPlant3", "TrueGangPlant4", "TrueGangPlant5", "TrueGangPlant6", "TrueGangPlant7", "TrueGangPlant8"}},
        
        // 劫身境 - 增加高阶和传说级真罡灵植
        {"Warrior8", new[] {"SpiritualPlant96", "SpiritualPlant97", "SpiritualPlant1", "TrueGangPlant5", "TrueGangPlant6", "TrueGangPlant7", "TrueGangPlant8", "TrueGangPlant9"}},
        
        // 武域境 - 增加高阶和传说级真罡灵植
        {"Warrior9", new[] {"SpiritualPlant98", "SpiritualPlant99", "TrueGangPlant7", "TrueGangPlant8", "TrueGangPlant9"}},
        
        // 合道境 - 增加高阶和传说级真罡灵植
        {"Warrior91", new[] {"SpiritualPlant94", "SpiritualPlant95", "SpiritualPlant96", "TrueGangPlant7", "TrueGangPlant8", "TrueGangPlant9"}},
        
        // 斩我境 - 增加传说级真罡灵植
        {"Warrior92", new[] {"SpiritualPlant97", "SpiritualPlant98", "SpiritualPlant99", "TrueGangPlant8", "TrueGangPlant9"}},
        
        // 武极境 - 增加传说级真罡灵植
        {"Warrior93", new[] {"SpiritualPlant99", "TrueGangPlant9"}}
    };

    // 在突破境界时随机获取灵植宝药
    private static void TryAddSpiritualPlant(Actor actor, string newRealmTrait)
    {
        // 保持0.5%稀有概率
        if (!Randy.randomChance(0.005f)) return;

        if (RealmToPlantsMap.TryGetValue(newRealmTrait, out var plantTraits))
        {
            // 确保配置了多个选项
            if (plantTraits.Length > 0) 
            {
                // 真随机选择（非固定首选项）
                int index = UnityEngine.Random.Range(0, plantTraits.Length);
                string selectedPlant = plantTraits[index];
                actor.addTrait(selectedPlant);
            }
        }
    }

        public static bool TrueDamage1_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 武域境(Warrior9)、合道境(Warrior91)、斩我境(Warrior92)、武极境(Warrior93)均无视此真伤
                if (targetActor.hasTrait("Warrior9") || targetActor.hasTrait("Warrior91") || 
                    targetActor.hasTrait("Warrior92") || targetActor.hasTrait("Warrior93"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 0.09f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 可以添加一些视觉效果，例如粒子效果
                EffectsLibrary.spawnExplosionWave(new Vector3(attacker.current_position.x, attacker.current_position.y, 0f), 0.02f, 2f);
            }
            return false;
        }
        public static bool TrueDamage2_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 武域境(Warrior9)、合道境(Warrior91)、斩我境(Warrior92)、武极境(Warrior93)均无视此真伤
                if (targetActor.hasTrait("Warrior9") || targetActor.hasTrait("Warrior91") || 
                    targetActor.hasTrait("Warrior92") || targetActor.hasTrait("Warrior93"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 0.1f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 可以添加一些视觉效果，例如粒子效果
                EffectsLibrary.spawnExplosionWave(new Vector3(attacker.current_position.x, attacker.current_position.y, 0f), 0.03f, 3f); 
            }
            return false;
        }
        public static bool TrueDamage3_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                if (targetActor.hasTrait("Warrior91") || targetActor.hasTrait("Warrior92") || targetActor.hasTrait("Warrior93"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 0.11f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 可以添加一些视觉效果，例如粒子效果
                EffectsLibrary.spawnExplosionWave(new Vector3(attacker.current_position.x, attacker.current_position.y, 0f), 0.04f, 4f);
            }
            return false;
        }
        public static bool TrueDamage4_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 斩我境(Warrior92)、武极境(Warrior93)无视此真伤
                if (targetActor.hasTrait("Warrior92") || targetActor.hasTrait("Warrior93"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 0.12f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 可以添加一些视觉效果，例如粒子效果
                EffectsLibrary.spawnExplosionWave(new Vector3(attacker.current_position.x, attacker.current_position.y, 0f), 0.05f, 5f);
            }
            return false;
        }
        
        // 阵道真伤攻击1级 - 基于阵纹值
        public static bool FormationPatternTrueDamage1_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 高级阵道境界无视此真伤
                if (targetActor.hasTrait("FormationRealm4") || targetActor.hasTrait("FormationRealm5") || targetActor.hasTrait("FormationRealm6"))
                {
                    return false;
                }
                // 获取攻击者的阵纹值作为伤害基础
                float patternValue = attacker.GetPattern();
                // 基于阵纹值计算真伤（50%的阵纹值）
                int trueDamage = (int)(patternValue * 0.50f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.02f); 
            }
            return false;
        }
        
        // 阵道真伤攻击2级 - 基于阵纹值
        public static bool FormationPatternTrueDamage2_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 高级阵道境界无视此真伤
                if (targetActor.hasTrait("FormationRealm5") || targetActor.hasTrait("FormationRealm6"))
                {
                    return false;
                }
                // 获取攻击者的阵纹值作为伤害基础
                float patternValue = attacker.GetPattern();
                // 基于阵纹值计算真伤（120%的阵纹值）
                int trueDamage = (int)(patternValue * 1.2f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.04f); 
            }
            return false;
        }
        
        // 阵道真伤攻击3级 - 基于阵纹值
        public static bool FormationPatternTrueDamage3_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 最高级阵道境界无视此真伤
                if (targetActor.hasTrait("FormationRealm6"))
                {
                    return false;
                }
                // 获取攻击者的阵纹值作为伤害基础
                float patternValue = attacker.GetPattern();
                // 基于阵纹值计算真伤（300%的阵纹值）
                int trueDamage = (int)(patternValue * 3.0f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.08f); 
            }
            return false;
        }
        
        // 阵道真伤攻击4级 - 基于阵纹值（最强）
        public static bool FormationPatternTrueDamage4_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 最高级阵道境界无视此真伤
                if (targetActor.hasTrait("FormationRealm6"))
                {
                    return false;
                }
                // 获取攻击者的阵纹值作为伤害基础
                float patternValue = attacker.GetPattern();
                // 基于阵纹值计算真伤（600%的阵纹值）
                int trueDamage = (int)(patternValue * 6.0f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.16f); 
            }
            return false;
        }

        // 阵道真伤攻击5级 - 基于阵纹值（最强）
        public static bool FormationPatternTrueDamage5_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 获取攻击者的阵纹值作为伤害基础
                float patternValue = attacker.GetPattern();
                // 基于阵纹值计算真伤（900%的阵纹值）
                int trueDamage = (int)(patternValue * 9.0f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.24f); 
            }
            return false;
        }

        // 阵道真伤攻击6级 - 基于阵纹值（最强）
        public static bool FormationPatternTrueDamage6_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 获取攻击者的阵纹值作为伤害基础
                float patternValue = attacker.GetPattern();
                // 基于阵纹值计算真伤（1500%的阵纹值）
                int trueDamage = (int)(patternValue * 15.0f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.32f); 
            }
            return false;
        }
        
        // 阵道真伤攻击1级 - 基于攻击值(damage)
        public static bool FormationDamageTrueDamage1_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 高级阵道境界无视此真伤
                if (targetActor.hasTrait("FormationRealm4") || targetActor.hasTrait("FormationRealm5") || targetActor.hasTrait("FormationRealm6"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                // 基于攻击力计算真伤（6%的攻击力）
                int trueDamage = (int)(attackDamage * 0.06f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false;
        }
        
        // 阵道真伤攻击2级 - 基于攻击值(damage)
        public static bool FormationDamageTrueDamage2_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 高级阵道境界无视此真伤
                if (targetActor.hasTrait("FormationRealm5") || targetActor.hasTrait("FormationRealm6"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                // 基于攻击力计算真伤（8%的攻击力）
                int trueDamage = (int)(attackDamage * 0.08f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.03f); 
            }
            return false;
        }
        
        // 阵道真伤攻击3级 - 基于攻击值(damage)
        public static bool FormationDamageTrueDamage3_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 最高级阵道境界无视此真伤
                if (targetActor.hasTrait("FormationRealm6"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                // 基于攻击力计算真伤（9%的攻击力）
                int trueDamage = (int)(attackDamage * 0.09f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.06f); 
            }
            return false;
        }
        
        // 阵道真伤攻击4级 - 基于攻击值(damage)（最强）
        public static bool FormationDamageTrueDamage4_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 最高级阵道境界无视此真伤
                if (targetActor.hasTrait("FormationRealm6"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                // 基于攻击力计算真伤（10%的攻击力）
                int trueDamage = (int)(attackDamage * 0.10f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.12f); 
            }
            return false;
        }
        
        // 阵道真伤攻击5级 - 基于攻击值(damage)（最强）
        public static bool FormationDamageTrueDamage5_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                // 基于攻击力计算真伤（11%的攻击力）
                int trueDamage = (int)(attackDamage * 0.11f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.24f); 
            }
            return false;
        }
        
        // 阵道真伤攻击6级 - 基于攻击值(damage)（最强）
        public static bool FormationDamageTrueDamage6_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                // 基于攻击力计算真伤（12%的攻击力）
                int trueDamage = (int)(attackDamage * 0.12f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 添加阵道特色的视觉效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.48f); 
            }
            return false;
        }

        public static bool TrueDamage5_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 武极境(Warrior93)无视此真伤
                if (targetActor.hasTrait("Warrior93"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 0.13f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 可以添加一些视觉效果，例如粒子效果
                EffectsLibrary.spawnExplosionWave(new Vector3(attacker.current_position.x, attacker.current_position.y, 0f), 0.06f, 6f);
            }
            return false;
        }
        public static bool TrueDamage6_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 武极境(Warrior93)无视此真伤
                if (targetActor.hasTrait("Warrior93"))
                {
                    return false;
                }
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 0.14f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 可以添加一些视觉效果，例如粒子效果
                EffectsLibrary.spawnExplosionWave(new Vector3(attacker.current_position.x, attacker.current_position.y, 0f), 0.08f, 6f);
            }
            return false;
        }
        public static bool TrueDamage7_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 0.15f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 可以添加一些视觉效果，例如粒子效果
                EffectsLibrary.spawnExplosionWave(new Vector3(attacker.current_position.x, attacker.current_position.y, 0f), 0.1f, 10f);
            }
            return false;
        }
        public static bool TrueDamage8_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 0.2f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false;
        }

        public static bool liuxing_attackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null)
            {
                pTile = pTarget.current_tile;
            }

            if (pTile == null)
            {
                return false;
            }


            {
                EffectsLibrary.spawn("fx_meteorite", pTile, "meteorite", null, 0f, -1f, -1f);
            }

            return true;
        }

        public static bool fire1_attackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null)
            {
                pTile = pTarget.current_tile;
            }

            if (pTile == null)
            {
                return false;
            }

            {
                EffectsLibrary.spawn("fx_bomb_flash", pTile,"Bomb", null, 0f, -1f, -1f);
            }

            return true;
        }

        public static bool fire2_attackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null)
            {
                pTile = pTarget.current_tile;
            }

            if (pTile == null)
            {
                return false;
            }

            {
                EffectsLibrary.spawn("fx_napalm_flash", pTile,"NapalmBomb", null, 0f, -1f, -1f);
            }

            return true;
        }

        public static bool TrueDamageByWarrior1_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 1. 检查目标是否有效（存在且是生物单位）
            if (pTarget == null || !pTarget.isActor() || pSelf == null || !pSelf.isActor()) 
                return false;
    
            Actor attacker = pSelf.a;
            Actor targetActor = pTarget.a;
    
            // 2. 获取攻击者的武道气血值
            float warriorValue = attacker.GetWarrior();
    
            // 3. 计算真实伤害（示例：气血值的20%作为基础伤害）
            float baseDamage = warriorValue * 0.2f;
    
            // 4. 添加伤害波动（±10%随机波动）
            float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
            int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
            // 5. 特殊规则：根据敌人境界减免伤害
            if (targetActor.hasTrait("Warrior93")) // 武极境减免90%伤害
                trueDamage = (int)(trueDamage * 0.1f);
            else if (targetActor.hasTrait("Warrior92")) // 斩我境减免50%伤害
                trueDamage = (int)(trueDamage * 0.5f);
    
            // 6. 施加真实伤害（无视防御）
            if (targetActor.data.health > trueDamage)
            {
                targetActor.restoreHealth(-trueDamage);
            }
            if (targetActor.data.health <= 0)
            {
                targetActor.batch.c_check_deaths.Add(targetActor);
            }
            AssetManager.terraform.get("lightning_normal").apply_force = false;
            MapBox.spawnLightningMedium(pTile, 0.12f);    
            return true;
        }

        public static bool TrueDamageByWarrior2_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 1. 检查目标是否有效（存在且是生物单位）
            if (pTarget == null || !pTarget.isActor() || pSelf == null || !pSelf.isActor()) 
                return false;
    
            Actor attacker = pSelf.a;
            Actor targetActor = pTarget.a;
    
            // 2. 获取攻击者的武道气血值
            float warriorValue = attacker.GetWarrior();
    
            // 3. 计算真实伤害（示例：气血值的30%作为基础伤害）
            float baseDamage = warriorValue * 0.3f;
    
            // 4. 添加伤害波动（±10%随机波动）
            float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
            int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
            // 5. 特殊规则：根据敌人境界减免伤害
            if (targetActor.hasTrait("Warrior93")) // 武极境减免50%伤害
                trueDamage = (int)(trueDamage * 0.5f);
    
            // 6. 施加真实伤害（无视防御）
            if (targetActor.data.health > trueDamage)
            {
                targetActor.restoreHealth(-trueDamage);
            }
            if (targetActor.data.health <= 0)
            {
                targetActor.batch.c_check_deaths.Add(targetActor);
            }
            AssetManager.terraform.get("lightning_normal").apply_force = false;
            MapBox.spawnLightningMedium(pTile, 0.24f);    
            return true;
        }

        public static bool TrueDamageByWarrior3_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 1. 检查目标是否有效（存在且是生物单位）
            if (pTarget == null || !pTarget.isActor() || pSelf == null || !pSelf.isActor()) 
                return false;
    
            Actor attacker = pSelf.a;
            Actor targetActor = pTarget.a;
    
            // 2. 获取攻击者的武道气血值
            float warriorValue = attacker.GetWarrior();
    
            // 3. 计算真实伤害（示例：气血值的50%作为基础伤害）
            float baseDamage = warriorValue * 0.5f;
    
            // 4. 添加伤害波动（±10%随机波动）
            float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
            int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
            // 5. 施加真实伤害（无视防御）
            if (targetActor.data.health > trueDamage)
            {
                targetActor.restoreHealth(-trueDamage);
            }
            if (targetActor.data.health <= 0)
            {
                targetActor.batch.c_check_deaths.Add(targetActor);
            }           
            return true;
        }

        public static bool MartialGodTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的1000%作为基础伤害）
                float baseDamage = warriorValue * 10f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }
        
        public static bool FormationSkill1_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 0.02f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 应用闪电效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.64f); 
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool FormationSkill2_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 0.01f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool FormationSkill4_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                // 10%概率触发真伤效果
                if (UnityEngine.Random.value <= 0.1f)
                {
                    float healthValue = attacker.stats[strings.S.health];
                    int trueDamage = Mathf.RoundToInt(healthValue * 0.1f); // 自身生命值的10%
        
                    // 确保至少造成1点伤害
                    if (trueDamage > 0 && targetActor.data.health > 0)
                    {
                        // 施加真实伤害（无视护甲/抗性）
                        int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                        targetActor.restoreHealth(-actualDamage);
                        
                        // 添加视觉效果
                        attacker.startColorEffect(ActorColorEffect.White);
                    }
                    
                    // 检查目标是否死亡
                    if (targetActor.data.health <= 0)
                    {
                        targetActor.batch.c_check_deaths.Add(targetActor);
                    }
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool XingdouJimie_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 0.01f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool Baiguang_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 0.01f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                attacker.startColorEffect(ActorColorEffect.White); 
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool FormationSkill3_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                // 检查目标生命值是否低于10%
                float maxHealth = targetActor.stats[strings.S.health];
                float currentHealth = targetActor.data.health;
                
                if (currentHealth > 0 && maxHealth > 0 && currentHealth / maxHealth <= 0.1f)
                {
                    // 1%概率直接扣除剩余血量
                    if (UnityEngine.Random.value <= 0.05f)
                    {
                        // 直接扣除所有剩余血量，转换为int类型
                        targetActor.restoreHealth(-Mathf.RoundToInt(currentHealth));
                        
                        // 添加死亡检查
                        if (targetActor.data.health <= 0)
                        {
                            targetActor.batch.c_check_deaths.Add(targetActor);
                        }
                    }
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool WanJieLunHui_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                // 检查目标生命值是否低于10%
                float maxHealth = targetActor.stats[strings.S.health];
                float currentHealth = targetActor.data.health;
                
                if (currentHealth > 0 && maxHealth > 0 && currentHealth / maxHealth <= 0.1f)
                {
                    // 10%概率直接扣除剩余血量
                    if (UnityEngine.Random.value <= 0.1f)
                    {
                        // 直接扣除所有剩余血量，转换为int类型
                        targetActor.restoreHealth(-Mathf.RoundToInt(currentHealth));
                        
                        // 添加死亡检查
                        if (targetActor.data.health <= 0)
                        {
                            targetActor.batch.c_check_deaths.Add(targetActor);
                        }
                    }
                }
            }
            return false; // 允许后续攻击动作继续执行
        } 

        public static bool FormationSkill5_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 0.02f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                // 应用闪电效果
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.64f); 
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool DaSunTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的800%作为基础伤害）
                float baseDamage = warriorValue * 8f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool TaiChuTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的1200%作为基础伤害）
                float baseDamage = warriorValue * 12f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool ZhuJieTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的1200%作为基础伤害）
                float baseDamage = warriorValue * 9f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool JieMieTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                // 获取攻击者的攻击力
                float attackDamage = attacker.stats["damage"];
                int trueDamage = (int)(attackDamage * 5f); 

                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-Mathf.Max(1, actualDamage));
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
                AssetManager.terraform.get("lightning_normal").apply_force = false;
                MapBox.spawnLightningMedium(pTile, 0.16f); 
            }
            return false;
        }

        public static bool QingTianTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的200%作为基础伤害）
                float baseDamage = warriorValue * 2f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool YunXingTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor() || pSelf == null || !pSelf.isActor())
                return false;

            Actor attacker = pSelf.a;
            Actor targetActor = pTarget.a;
    
            // 获取攻击者当前生命值
            float currentHealth = attacker.data.health;
    
            // 计算真实伤害 = 攻击者生命值的1.25%
            int trueDamage = (int)(currentHealth / 80);
    
            // 确保至少造成1点伤害
            if (trueDamage < 1) trueDamage = 1;
    
            // 施加真实伤害（无视防御）
            if (targetActor.data.health > trueDamage)
            {
                targetActor.restoreHealth(-trueDamage);
            }
            else
            {
                // 如果伤害超过目标血量，直接击杀
                targetActor.restoreHealth(-targetActor.data.health);
            }
            if (targetActor.data.health <= 0)
            {
                targetActor.batch.c_check_deaths.Add(targetActor);
            }
            return true;
        }

        public static bool WanZhanTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor() || pSelf == null || !pSelf.isActor())
                return false;

            Actor attacker = pSelf.a;
            Actor targetActor = pTarget.a;
    
            // 获取攻击者当前生命值
            float currentHealth = attacker.data.health;
    
            // 计算真实伤害 = 攻击者生命值的1%
            int trueDamage = (int)(currentHealth / 100);
    
            // 确保至少造成1点伤害
            if (trueDamage < 1) trueDamage = 1;
    
            // 施加真实伤害（无视防御）
            if (targetActor.data.health > trueDamage)
            {
                targetActor.restoreHealth(-trueDamage);
            }
            else
            {
                // 如果伤害超过目标血量，直接击杀
                targetActor.restoreHealth(-targetActor.data.health);
            }
            if (targetActor.data.health <= 0)
            {
                targetActor.batch.c_check_deaths.Add(targetActor);
            }
            return true;
        }

        public static bool BloodSeaTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                float killCount = attacker.data.kills;
                int trueDamage =  (int)(killCount* 100f); 

                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false;
        }

        public static bool JiuYuanTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                float killCount = attacker.data.kills;
                int trueDamage =  (int)(killCount* 120f); 

                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false;
        }

        public static bool ArmorBasedTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                // 获取攻击者的防御值（armor属性）
                float armorValue = attacker.stats[strings.S.armor];
        
                // 计算真实伤害 = 防御值 * 100
                int trueDamage = Mathf.RoundToInt(armorValue * 100f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool ManLongTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 0.01f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool DiYinTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 10f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }
        
        // 戮王印真伤效果
        public static bool LuWangYinTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 5f); // 真伤是生命值的5倍
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool XuKongTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float healthValue = attacker.stats[strings.S.health];
        
                int trueDamage = Mathf.RoundToInt(healthValue * 0.005f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool XingChenTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float staminaValue = attacker.stats[strings.S.stamina];
        
                int trueDamage = Mathf.RoundToInt(staminaValue * 3f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool WanHeTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float staminaValue = attacker.stats[strings.S.stamina];
        
                int trueDamage = Mathf.RoundToInt(staminaValue * 8f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool GengGuTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float staminaValue = attacker.stats[strings.S.stamina];
        
                int trueDamage = Mathf.RoundToInt(staminaValue * 10f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool TaiYinTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float staminaValue = attacker.stats[strings.S.stamina];
        
                int trueDamage = Mathf.RoundToInt(staminaValue * 4f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool HunDunTrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float speedValue = attacker.stats[strings.S.speed];
        
                int trueDamage = Mathf.RoundToInt(speedValue * 50f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool NineCharacterSecret1TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的两倍作为基础伤害）
                float baseDamage = warriorValue * 2.4f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool NineCharacterSecret2TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的两倍作为基础伤害）
                float baseDamage = warriorValue * 3f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool NineCharacterSecret4TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的两倍作为基础伤害）
                float baseDamage = warriorValue * 3.6f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool NineCharacterSecret3TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的两倍作为基础伤害）
                float baseDamage = warriorValue * 2.0f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool NineCharacterSecret5TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
        
                float speedValue = attacker.stats[strings.S.speed];
        
                int trueDamage = Mathf.RoundToInt(speedValue * 80f);
        
                // 确保至少造成1点伤害
                if (trueDamage > 0 && targetActor.data.health > 0)
                {
                    // 施加真实伤害（无视护甲/抗性）
                    int actualDamage = Mathf.Min(trueDamage, targetActor.data.health);
                    targetActor.restoreHealth(-actualDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }
            return false; // 允许后续攻击动作继续执行
        }

        public static bool NineCharacterSecret6TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的两倍作为基础伤害）
                float baseDamage = warriorValue * 1.5f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool NineCharacterSecret7TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的两倍作为基础伤害）
                float baseDamage = warriorValue * 3f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool NineCharacterSecret8TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的两倍作为基础伤害）
                float baseDamage = warriorValue * 1.2f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool NineCharacterSecret9TrueDamage_AttackAction(BaseSimObject pSelf, BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor() && pSelf.isActor())
            {
                Actor attacker = pSelf.a;
                Actor targetActor = pTarget.a;
                
                // 2. 获取攻击者的武道气血值
                float warriorValue = attacker.GetWarrior();
    
                // 3. 计算真实伤害（示例：气血值的两倍作为基础伤害）
                float baseDamage = warriorValue * 4f;
    
                // 4. 添加伤害波动（±10%随机波动）
                float randomFactor = UnityEngine.Random.Range(0.9f, 1.1f);
                int trueDamage = Mathf.RoundToInt(baseDamage * randomFactor);
    
                // 5. 施加真实伤害（无视防御）
                if (targetActor.data.health > trueDamage)
                {
                    targetActor.restoreHealth(-trueDamage);
                }
                else
               {
                    // 如果伤害超过目标血量，直接击杀
                    targetActor.restoreHealth(-targetActor.data.health);
                }
                if (targetActor.data.health <= 0)
                {
                    targetActor.batch.c_check_deaths.Add(targetActor);
                }
            }

            return false;
        }

        public static bool MaintainFullNutrition(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget != null && pTarget.isActor())
            {
                Actor actor = pTarget.a;
                if (actor.hasTrait("Warrior91") || 
                    actor.hasTrait("Warrior92") || 
                    actor.hasTrait("FormationRealm6") || 
                    actor.hasTrait("Warrior93"))
                {
                    // 保持饱食度100%
                    actor.data.nutrition = 100;
                }
            }
            return true;
        }      

        // 优化：缓存禁止特质数组为静态字段，避免每次调用都创建新数组
        private static readonly string[] _forbiddenWarriorTraits = { "Warrior2", "Warrior3", "Warrior4", "Warrior5", "Warrior6", "Warrior7", "Warrior8", "Warrior9", "Warrior91", "Warrior92", "Warrior93" };
        private static readonly string[] _negativeTraitsToRemove = { "tumorInfection", "cursed", "infected", "mushSpores", "plague", "madness" };
        private static readonly string[] _traitsToAdd = { "特质" };
        
        // 阵道境界晋升路径
        private static readonly Dictionary<string, string> FormationEvolutionPath = new Dictionary<string, string>()
        {
            { "FormationRealm1", "FormationRealm2" },
            { "FormationRealm2", "FormationRealm3" },
            { "FormationRealm3", "FormationRealm4" },
            { "FormationRealm4", "FormationRealm5" },
            { "FormationRealm5", "FormationRealm6" }
        };
                
        // 阵道相关缓存数组
        private static readonly string[] _forbiddenFormationTraits = { "tumorInfection", "cursed", "infected", "mushSpores" };
        
        // 阵道第一重境界晋升效果
        public static bool FormationRealm1_effectAction(BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor()) return false;
            Actor a = pTarget.a;
            
            // 检查是否为有效角色
            if (!a.isAlive()) return false;
            
            // 检查阵纹值是否达到晋升阈值
            float patternValue = a.GetPattern();
            if (patternValue < 50f) return false;
            
            // 检查是否已经拥有高阶阵道境界特质
            bool hasHigherRealm = false;
            for (int i = 2; i <= 6; i++)
            {
                if (a.hasTrait($"FormationRealm{i}"))
                {
                    hasHigherRealm = true;
                    break;
                }
            }
            if (hasHigherRealm) return false;
            
            // 检查是否有禁忌特质
            foreach (string trait in _forbiddenFormationTraits)
            {
                if (a.hasTrait(trait))
                {
                    return false;
                }
            }
            
            // 计算成功率：不同阵道天赋对应不同的成功率
            double successRate = 0.5; // 默认成功率
            
            // 根据阵道天赋特质调整成功率
            if (a.hasTrait("formation4")) // 最高级阵道天赋
            {
                successRate = 1.0; // 100%成功率
            }
            else if (a.hasTrait("formation3"))
            {
                successRate = 0.8; // 80%成功率
            }
            else if (a.hasTrait("formation2"))
            {
                successRate = 0.6; // 60%成功率
            }
            else if (a.hasTrait("formation1"))
            {
                successRate = 0.4; // 40%成功率
            }
            
            // 进行随机判定
            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则晋升失败
            }
            
            // 准备要添加的特质数组
            string[] traitsToAdd = { "fire_proof", "freeze_proof" };
            // 添加阵道第一重境界特质和额外特质
            upTrait("特质", "FormationRealm1", a, _forbiddenFormationTraits, traitsToAdd);          
            // 更新阵道境界名称后缀
            UpdateFormationNameSuffix(a, "FormationRealm1");
            return true;
        }
        
        public static bool FormationRealm2_effectAction(BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor()) return false;
            Actor a = pTarget.a;
            
            // 检查是否为有效角色
            if (!a.isAlive()) return false;
            
            // 检查是否拥有前一境界特质
            if (!a.hasTrait("FormationRealm1")) return false;
            
            // 检查阵纹值是否达到晋升阈值
            float patternValue = a.GetPattern();
            if (patternValue < 100f) return false;
            
            // 检查是否有禁忌特质
            foreach (string trait in _forbiddenFormationTraits)
            {
                if (a.hasTrait(trait))
                {
                    return false;
                }
            }
            
            // 消耗阵纹值
            a.ChangePattern(-10f);
            
            // 计算成功率
            double successRate = 0.6; // 默认成功率
            
            // 根据阵道天赋特质调整成功率
            if (a.hasTrait("formation4"))
            {
                successRate = 0.8; // 100%成功率
            }
            else if (a.hasTrait("formation3"))
            {
                successRate = 0.6; // 80%成功率
            }
            else if (a.hasTrait("formation2"))
            {
                successRate = 0.4; // 60%成功率
            }
            else if (a.hasTrait("formation1"))
            {
                successRate = 0.2; // 40%成功率
            }
            
            // 进行随机判定
            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则晋升失败
            }
            
            // 准备要添加的特质数组
            string[] traitsToAdd = { "bubble_defense", "immune", "tough" };
            // 替换特质，从FormationRealm1晋升到FormationRealm2并添加额外特质
            upTrait("FormationRealm1", "FormationRealm2", a, _forbiddenFormationTraits, traitsToAdd);
            // 更新阵道境界名称后缀
            UpdateFormationNameSuffix(a, "FormationRealm2");
            // 应用阵道尊号前缀
            ApplyFormationTitle(a, "FormationRealm2");
            return true;
        }
        
        public static bool FormationRealm3_effectAction(BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor()) return false;
            Actor a = pTarget.a;
            
            // 检查是否为有效角色
            if (!a.isAlive()) return false;
            
            // 检查是否拥有前一境界特质
            if (!a.hasTrait("FormationRealm2")) return false;
            

            
            // 获取并检查阵纹值是否达到晋升阈值
            float patternValue = a.GetPattern();
            if (patternValue < 200f) return false;
            
            // 检查是否有禁忌特质
            foreach (string trait in _forbiddenFormationTraits)
            {
                if (a.hasTrait(trait))
                {
                    return false;
                }
            }
            
            // 消耗阵纹值
            a.ChangePattern(-20f);
            
            // 计算成功率
            double successRate = 0.5; // 默认成功率
            
            // 根据阵道天赋特质调整成功率
            if (a.hasTrait("formation4"))
            {
                successRate = 0.6; // 100%成功率
            }
            else if (a.hasTrait("formation3"))
            {
                successRate = 0.4; // 70%成功率
            }
            else if (a.hasTrait("formation2"))
            {
                successRate = 0.2; // 50%成功率
            }
            else if (a.hasTrait("formation1"))
            {
                successRate = 0.1; // 30%成功率
            }
            
            // 进行随机判定
            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则晋升失败
            }
            
            // 准备要添加的特质数组
            string[] traitsToAdd = { "acid_proof", "poison_immune", "regeneration" };
            // 替换特质，从FormationRealm2晋升到FormationRealm3并添加额外特质
            upTrait("FormationRealm2", "FormationRealm3", a, _forbiddenFormationTraits, traitsToAdd);
            // 更新阵道境界名称后缀
            UpdateFormationNameSuffix(a, "FormationRealm3");
            return true;
        }
        
        public static bool FormationRealm4_effectAction(BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor()) return false;
            Actor a = pTarget.a;
            
            // 检查是否为有效角色
            if (!a.isAlive()) return false;
            
            // 检查是否拥有前一境界特质
            if (!a.hasTrait("FormationRealm3")) return false;
                  
            // 获取并检查阵纹值是否达到晋升阈值
            float patternValue = a.GetPattern();
            if (patternValue < 400f) return false;
            
            // 检查是否有禁忌特质
            foreach (string trait in _forbiddenFormationTraits)
            {
                if (a.hasTrait(trait))
                {
                    return false;
                }
            }
            
            // 消耗阵纹值
            a.ChangePattern(-30f);
            
            // 计算成功率
            double successRate = 0.4; // 默认成功率
            
            // 根据阵道天赋特质调整成功率
            if (a.hasTrait("formation4"))
            {
                successRate = 0.4; // 100%成功率
            }
            else if (a.hasTrait("formation3"))
            {
                successRate = 0.2; // 60%成功率
            }
            else if (a.hasTrait("formation2"))
            {
                successRate = 0.1; // 40%成功率
            }
            else if (a.hasTrait("formation1"))
            {
                successRate = 0.05; // 20%成功率
            }
            
            // 进行随机判定
            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则晋升失败
            }
            
            // 准备要添加的特质数组
            string[] traitsToAdd = { "dodge", "deflect_projectile", "dash" };
            // 替换特质，从FormationRealm3晋升到FormationRealm4并添加额外特质
            upTrait("FormationRealm3", "FormationRealm4", a, _forbiddenFormationTraits, traitsToAdd);
            // 更新阵道境界名称后缀
            UpdateFormationNameSuffix(a, "FormationRealm4");
            // 应用阵道尊号前缀
            ApplyFormationTitle(a, "FormationRealm4");
            return true;
        }
        
        public static bool FormationRealm5_effectAction(BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor()) return false;
            Actor a = pTarget.a;
            
            // 检查是否为有效角色
            if (!a.isAlive()) return false;
            
            // 检查是否拥有前一境界特质
            if (!a.hasTrait("FormationRealm4")) return false;
            

            
            // 获取并检查阵纹值是否达到晋升阈值
            float patternValue = a.GetPattern();
            if (patternValue < 800f) return false;
            
            // 检查是否有禁忌特质
            foreach (string trait in _forbiddenFormationTraits)
            {
                if (a.hasTrait(trait))
                {
                    return false;
                }
            }
            
            // 消耗阵纹值
            a.ChangePattern(-40f);
            
            // 计算成功率
            double successRate = 0.3; // 默认成功率
            
            // 根据阵道天赋特质调整成功率
            if (a.hasTrait("formation4"))
            {
                successRate = 0.2; // 100%成功率
            }
            else if (a.hasTrait("formation3"))
            {
                successRate = 0.1; // 50%成功率
            }
            else if (a.hasTrait("formation2"))
            {
                successRate = 0.05; // 30%成功率
            }
            else if (a.hasTrait("formation1"))
            {
                successRate = 0.01; // 10%成功率
            }
            
            // 进行随机判定
            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则晋升失败
            }
            
            // 准备要添加的特质数组
            string[] traitsToAdd = { "block", "backstep" };
            // 替换特质，从FormationRealm4晋升到FormationRealm5并添加额外特质
            upTrait("FormationRealm4", "FormationRealm5", a, _forbiddenFormationTraits, traitsToAdd);
            // 更新阵道境界名称后缀
            UpdateFormationNameSuffix(a, "FormationRealm5");
            // 应用阵道尊号前缀
            ApplyFormationTitle(a, "FormationRealm5");
            return true;
        }
        
        public static bool FormationRealm6_effectAction(BaseSimObject pTarget, WorldTile pTile = null)
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor()) return false;
            Actor a = pTarget.a;
            
            // 检查是否为有效角色
            if (!a.isAlive()) return false;
            
            // 检查是否拥有前一境界特质
            if (!a.hasTrait("FormationRealm5")) return false;
                      
            // 获取并检查阵纹值是否达到晋升阈值
            float patternValue = a.GetPattern();
            if (patternValue < 1600f) return false;
            
            // 检查是否有禁忌特质
            foreach (string trait in _forbiddenFormationTraits)
            {
                if (a.hasTrait(trait))
                {
                    return false;
                }
            }
            
            // 消耗阵纹值
            a.ChangePattern(-50f);
            
            // 计算成功率
            double successRate = 0.1; // 默认成功率
            
            // 根据阵道天赋特质调整成功率
            if (a.hasTrait("formation4"))
            {
                successRate = 0.8; // 80%成功率
            }
            else if (a.hasTrait("formation3"))
            {
                successRate = 0.4; // 40%成功率
            }
            else if (a.hasTrait("formation2"))
            {
                successRate = 0.2; // 20%成功率
            }
            else if (a.hasTrait("formation1"))
            {
                successRate = 0.05; // 5%成功率
            }
            
            // 进行随机判定
            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则晋升失败
            }
            
            // 准备要添加的特质数组
            string[] traitsToAdd = { "genius", "strong_minded" };
            // 替换特质，从FormationRealm5晋升到FormationRealm6并添加额外特质
            upTrait("FormationRealm5", "FormationRealm6", a, _forbiddenFormationTraits, traitsToAdd);
            // 更新阵道境界名称后缀
            UpdateFormationNameSuffix(a, "FormationRealm6");
            // 应用阵道尊号前缀
            ApplyFormationTitle(a, "FormationRealm6");
            
            // 根据配置选项决定是否自动收藏阵道最高境界角色
            if (WarriorConfig.AutoCollectXuanZhen)
            {
                a.data.favorite = true;
            }
            // 阵道最高境界突破播报
            NotificationHelper.ShowFormationRealm6Notification(a);
            
            // 检查是否已拥有任何阵法特质
            bool hasFormationSkill = a.hasTrait("FormationSkill1") || 
                                    a.hasTrait("FormationSkill2") || 
                                    a.hasTrait("FormationSkill3") || 
                                    a.hasTrait("FormationSkill4") || 
                                    a.hasTrait("FormationSkill5");
            
            // 如果没有阵法特质，则根据概率添加一个
            if (!hasFormationSkill)
            {
                // 生成随机数决定获得哪个阵法
                double formationRandom = UnityEngine.Random.Range(0.0f, 1.0f);
                string formationToAdd = null;
                
                if (formationRandom <= 0.5)  // 50%概率
                {
                    formationToAdd = "FormationSkill1";
                }
                else if (formationRandom <= 0.8)  // 30%概率
                {
                    formationToAdd = "FormationSkill2";
                }
                else if (formationRandom <= 0.95)  // 15%概率
                {
                    formationToAdd = "FormationSkill3";
                }
                else if (formationRandom <= 0.99)  // 4%概率
                {
                    formationToAdd = "FormationSkill4";
                }
                else  // 1%概率
                {
                    formationToAdd = "FormationSkill5";
                }
                
                // 添加选定的阵法特质
                if (!string.IsNullOrEmpty(formationToAdd))
                {
                    a.addTrait(formationToAdd);
                }
            }
            
            return true;
        }
        
        public static bool Warrior1_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;

            // 气血值检查
            if (a.GetWarrior() <= 4.99)
            {
                return false;
            }

            // 优化：使用已有的 a 变量，避免重复访问 pTarget.a
            foreach (string trait in _forbiddenWarriorTraits)
            {
                if (a.hasTrait(trait))
                {
                    return false;
                }
            }

            // 使用预缓存的数组
            upTrait("特质", "Warrior1", a, _negativeTraitsToRemove, _traitsToAdd);
            UpdateNameSuffix(a, "Warrior1");

            return true;
        }

        // 优化：缓存数组为静态字段
        private static readonly string[] _warrior2NegativeTraitsToRemove = { "tumorInfection", "cursed", "infected", "mushSpores" };
        private static readonly string[] _warrior2TraitsToAdd = { "Warrior22" };
        
        public static bool Warrior2_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            
            // 合并条件检查
            if (WarriorConfig.LimitWarrior2 || a.GetWarrior() <= 9.99)
            {
                return false;
            }

            a.ChangeWarrior(-2);
            
            // 优化：计算成功率的逻辑
            double successRate = 0.8;
            
            // 按照优先级顺序检查天赋特质
            // martialAptitude4, 7, 8的成功率相同，可以合并检查
            if (a.hasTrait("martialAptitude4") || a.hasTrait("martialAptitude7") || a.hasTrait("martialAptitude8"))
            {
                successRate = 1.0;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.6;
            }
            else if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.3;
            }
            // martialAptitude3的成功率与默认值相同，可以省略检查

            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则操作失败
            }

            // 使用预缓存的数组
            upTrait("Warrior1", "Warrior2", a, _warrior2NegativeTraitsToRemove, _warrior2TraitsToAdd);
            UpdateNameSuffix(a, "Warrior2");

            return true;
        }

        // 优化：缓存数组为静态字段
        private static readonly string[] _warrior3NegativeTraitsToRemove = { "tumorInfection", "cursed", "infected", "mushSpores", "Warrior22" };
        private static readonly string[] _optionalTraits = { "dash", "block", "dodge", "backstep", "deflect_projectile" };
        private static readonly string[] _lowGongFaTraits = { "LowGongFaTrait1", "LowGongFaTrait2", "LowGongFaTrait9", "LowGongFaTrait3", "LowGongFaTrait4", "LowGongFaTrait5", "LowGongFaTrait6", "LowGongFaTrait7", "LowGongFaTrait8" };
        
        public static bool Warrior3_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            // 快速失败检查
            if (pTarget == null || !pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            
            // 合并条件检查
            if (WarriorConfig.LimitWarrior3)
            {
                return false;
            }
            
            // 检查气血值是否小于8，如果是，则趺落境界
            if (a.GetWarrior() < 8)
            {
                // 添加Warrior1特质
                upTrait("特质", "Warrior1", a, new string[] { "Warrior2" }, new string[] { });
                return true; // 趺落境界处理完毕，返回true
            }
            
            // 气血值不足
            if (a.GetWarrior() <= 19.99)
            {
                return false;
            }

            a.ChangeWarrior(-2);
            
            // 优化：计算成功率的逻辑
            double successRate = 0.6;
            
            // 按照优先级顺序检查天赋特质
            // martialAptitude7, 8的成功率相同，可以合并检查
            if (a.hasTrait("martialAptitude7") || a.hasTrait("martialAptitude8"))
            {
                successRate = 1.0;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.8;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.7;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.5;
            }
            else if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.2;
            }

            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则操作失败
            }
            
            // 使用预缓存的数组
            int randomIndex = UnityEngine.Random.Range(0, _optionalTraits.Length);
            string selectedTrait = _optionalTraits[randomIndex];
            
            // 构建要添加的特质数组（只创建一次）
            string[] traitsToAdd = { "Warrior3+", selectedTrait };
            
            upTrait("Warrior2", "Warrior3", a, _warrior3NegativeTraitsToRemove, traitsToAdd);
            UpdateNameSuffix(a, "Warrior3");

            // 随机选择一个低级功法特质添加给人物
            int randomIndex1 = UnityEngine.Random.Range(0, _lowGongFaTraits.Length);
            string selectedLowGongFa = _lowGongFaTraits[randomIndex1]; // 修复：使用正确的索引变量
            a.addTrait(selectedLowGongFa);
            
            // 尝试添加灵植宝药
            TryAddSpiritualPlant(a, "Warrior3");

            return true;
        }

        public static bool Warrior4_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            if (WarriorConfig.LimitWarrior4)
            {
                return false;
            }
            // 检查气血值是否小于x，如果是，则趺落境界
            if (a.GetWarrior() < 18)
            {
                upTrait("特质", "Warrior2", a, new string[] { "Warrior3" }, new string[] { });
                return true; // 趺落境界处理完毕，返回true
            }

            if (a.GetWarrior() <= 39.99)
            {
                return false;
            }

            a.ChangeWarrior(-3);
            double successRate = 0.6;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.2;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.4;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.6;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.8;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 1.0;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 1.0;
            }

            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则操作失败
            }

            upTrait(
                "Warrior3",
                "Warrior4",
                a,
                new string[]
                {
                    "tumorInfection",
                    "cursed",
                    "infected",
                    "mushSpores",
                    "Warrior3+"
                },
                new string[] { "Warrior4+" }
            );
            UpdateNameSuffix(a, "Warrior4");

            bool hasAnyAncientMartialBody = 
                a.hasTrait("ancientMartialBody1") ||
                a.hasTrait("ancientMartialBody2") ||
                a.hasTrait("ancientMartialBody3") ||
                a.hasTrait("ancientMartialBody4") ||
                a.hasTrait("ancientMartialBody5") ||
                a.hasTrait("ancientMartialBody6") ||
                a.hasTrait("ancientMartialBody7") ||
                a.hasTrait("ancientMartialBody8") ||
                a.hasTrait("ancientMartialBody9") ||
                a.hasTrait("ancientMartialBody91") ||
                a.hasTrait("ancientMartialBody92") ||
                a.hasTrait("ancientMartialBody93") ||
                a.hasTrait("ancientMartialBody94") ||
                a.hasTrait("ancientMartialBody95") ||
                a.hasTrait("ancientMartialBody96") ||
                a.hasTrait("ancientMartialBody97") ||
                a.hasTrait("ancientMartialBody98") ||
                a.hasTrait("ancientMartialBody99");
            
            string selectedTrait = null; // 在外部声明变量

            if (!hasAnyAncientMartialBody && UnityEngine.Random.Range(0f, 1f) < 0.005f)
            {
                string[] ancientMartialBodies = {
                    "ancientMartialBody1",
                    "ancientMartialBody2",
                    "ancientMartialBody3",
                    "ancientMartialBody4",
                    "ancientMartialBody5",
                    "ancientMartialBody6",
                    "ancientMartialBody7",
                    "ancientMartialBody8",
                    "ancientMartialBody9",
                    "ancientMartialBody92",
                    "ancientMartialBody93",
                    "ancientMartialBody95",
                    "ancientMartialBody96",
                    "ancientMartialBody97",
                    "ancientMartialBody98",
                    "ancientMartialBody99"
                };
        
                selectedTrait = ancientMartialBodies[UnityEngine.Random.Range(0, ancientMartialBodies.Length)]; // 赋值
                a.addTrait(selectedTrait, false);
                if (selectedTrait == "ancientMartialBody1" || 
                    selectedTrait == "ancientMartialBody4" || 
                    selectedTrait == "ancientMartialBody96" ||
                    selectedTrait == "ancientMartialBody9")
                {
                    a.data.favorite = true;
                }
            }

            if (selectedTrait != null) // 添加空值检查
           {
                NotificationHelper.ShowMartialBodyNotification(a, selectedTrait);
           }
           TryAddSpiritualPlant(a, "Warrior4");
    
            return true;
        }

        public static bool Warrior5_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            if (WarriorConfig.LimitWarrior5)
            {
                return false;
            }
            // 检查气血值是否小于x，如果是，则趺落境界
            if (a.GetWarrior() < 37)
            {
                upTrait("特质", "Warrior3", a, new string[] { "Warrior4" }, new string[] { });
                return true; // 趺落境界处理完毕，返回true
            }

            if (a.GetWarrior() <= 79.99)
            {
                return false;
            }

            a.ChangeWarrior(-4);
            double successRate = 0.6;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.1;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.2;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.5;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.8;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 1.0;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 1.0;
            }

            var ancientBodyModifiers = new Dictionary<string, double>
            {
                {"ancientMartialBody1", 0.88},
                {"ancientMartialBody2", 1.2},
                {"ancientMartialBody3", 2.0},
                {"ancientMartialBody4", 1.25},
                {"ancientMartialBody5", 1.0},
                {"ancientMartialBody6", 1.2},
                {"ancientMartialBody7", 0.95},
                {"ancientMartialBody8", 1.5},
                {"ancientMartialBody9", 0.9},
                {"ancientMartialBody91", 1.8},
                {"ancientMartialBody92", 1.1},
                {"ancientMartialBody93", 1.2},
                {"ancientMartialBody94", 0.95},
                {"ancientMartialBody95", 1.0},
                {"ancientMartialBody96", 1.2},
                {"ancientMartialBody97", 0.99},
                {"ancientMartialBody98", 1.25},
                {"ancientMartialBody99", 1.3}
            };
    
            // 检查所有荒古武躯特质并应用修正
            foreach (var trait in ancientBodyModifiers.Keys)
            {
                if (a.hasTrait(trait))
                {
                    successRate *= ancientBodyModifiers[trait];
                }
            }

            // 检查是否有邪功特质，如果有则降低成功率为原先的五分之四
            if (a.hasTrait("EvilGongFa1") || a.hasTrait("EvilGongFa2") || a.hasTrait("EvilGongFa3"))
            {
                successRate *= 0.8;
            }

            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false;
            }
            string[] optionalTraits = { "dash", "block", "dodge", "backstep", "deflect_projectile" };
            string selectedTrait = null;
            // 检查是否所有可选特质都已被拥有
            bool allTraitsOwned = optionalTraits.All(trait => a.hasTrait(trait));
            if (!allTraitsOwned)
            {
                var availableTraits = optionalTraits.Where(t => !a.hasTrait(t)).ToList();
                selectedTrait = availableTraits[UnityEngine.Random.Range(0, availableTraits.Count)];
            }


            upTrait(
                "Warrior4",
                "Warrior5",
                a,
                new string[]
                {
                    "tumorInfection",
                    "cursed",
                    "infected",
                    "mushSpores",
                    "Warrior4+"
                },
                (selectedTrait != null) ?
                new string[] { "Warrior5+", selectedTrait } :
                new string[] { "Warrior5+" }
            );
            UpdateNameSuffix(a, "Warrior5");
            TryAddSpiritualPlant(a, "Warrior5");

            return true;
        }

        public static bool Warrior6_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            if (WarriorConfig.LimitWarrior6)
            {
                return false;
            }
            // 检查气血值是否小于x，如果是，则趺落境界
            if (a.GetWarrior() < 76)
            {
                upTrait("特质", "Warrior4", a, new string[] { "Warrior5" }, new string[] { });
                return true; // 趺落境界处理完毕，返回true
            }

            if (a.GetWarrior() <= 159.99)
            {
                return false;
            }

            a.ChangeWarrior(-5);
            double successRate = 0.1;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.05;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.1;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.2;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.4;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 0.5;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 0.8;
            }

            var ancientBodyModifiers = new Dictionary<string, double>
            {
                {"ancientMartialBody1", 0.88},
                {"ancientMartialBody2", 1.2},
                {"ancientMartialBody3", 2.0},
                {"ancientMartialBody4", 1.25},
                {"ancientMartialBody5", 1.0},
                {"ancientMartialBody6", 1.2},
                {"ancientMartialBody7", 0.95},
                {"ancientMartialBody8", 1.5},
                {"ancientMartialBody9", 0.9},
                {"ancientMartialBody91", 1.8},
                {"ancientMartialBody92", 1.1},
                {"ancientMartialBody93", 1.2},
                {"ancientMartialBody94", 0.95},
                {"ancientMartialBody95", 1.0},
                {"ancientMartialBody96", 1.2},
                {"ancientMartialBody97", 0.99},
                {"ancientMartialBody98", 1.25},
                {"ancientMartialBody99", 1.3}
            };
    
            // 检查所有荒古武躯特质并应用修正
            foreach (var trait in ancientBodyModifiers.Keys)
            {
                if (a.hasTrait(trait))
                {
                    successRate *= ancientBodyModifiers[trait];
                }
            }

            double randomValue = UnityEngine.Random.Range(0.0f, 1.0f);
            if (randomValue > successRate)
            {
                return false; // 随机数大于成功率，则操作失败
            }
            string[] optionalTraits = { "dash", "block", "dodge", "backstep", "deflect_projectile" };
            string selectedTrait = null;
            // 检查是否所有可选特质都已被拥有
            bool allTraitsOwned = optionalTraits.All(trait => a.hasTrait(trait));
            if (!allTraitsOwned)
            {
                var availableTraits = optionalTraits.Where(t => !a.hasTrait(t)).ToList();
                selectedTrait = availableTraits[UnityEngine.Random.Range(0, availableTraits.Count)];
            }


            upTrait(
                "Warrior5",
                "Warrior6",
                a,
                new string[]
                {
                    "tumorInfection",
                    "cursed",
                    "infected",
                    "mushSpores",
                    "Warrior5+"
                },
                (selectedTrait != null) ?
                new string[] { "Warrior6+", "freeze_proof", "fire_proof", "martialBloodline1", selectedTrait } :
                new string[] { "Warrior6+", "freeze_proof", "fire_proof" }
            );
            UpdateNameSuffix(a, "Warrior6");

            string[] midGongFaTraits = {
                "MidGongFaTrait1", "MidGongFaTrait2", "MidGongFaTrait3", "MidGongFaTrait4",
                "MidGongFaTrait5", "MidGongFaTrait6", "MidGongFaTrait7", "MidGongFaTrait8",
                "MidGongFaTrait9", "MidGongFaTrait10", "MidGongFaTrait11", "MidGongFaTrait12",
                "MidGongFaTrait13", "MidGongFaTrait14", "EvilGongFa2"
            };

            // 随机决定获得特质的数量（1 - 2 个）
            int traitCount = UnityEngine.Random.Range(1, 3);

            // 随机选择特质
            List<string> selectedTraits = new List<string>();
            while (selectedTraits.Count < traitCount)
            {
                int randomIndex = UnityEngine.Random.Range(0, midGongFaTraits.Length);
                string traitId = midGongFaTraits[randomIndex];
                if (!selectedTraits.Contains(traitId))
                {
                    selectedTraits.Add(traitId);
                    a.addTrait(traitId, false);
                }
            }
            TryAddSpiritualPlant(a, "Warrior6");

            return true;
        }

        public static bool Warrior7_effectAction(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            if (WarriorConfig.LimitWarrior7)
            {
                return false;
            }
            // 检查气血值是否小于x，如果是，则趺落境界
            if (a.GetWarrior() < 155)
            {
                upTrait("特质", "Warrior6", a, new string[] { "Warrior7" }, new string[] { });
                return true;
            }

            if (a.GetWarrior() <= 299.99)
            {
                return false;
            }

            a.ChangeWarrior(-6);
            double successRate = 0.1;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.01;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.05;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.1;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.2;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 0.5;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 0.8;
            }

            var ancientBodyModifiers = new Dictionary<string, double>
            {
                {"ancientMartialBody1", 0.88},
                {"ancientMartialBody2", 1.2},
                {"ancientMartialBody3", 2.0},
                {"ancientMartialBody4", 1.25},
                {"ancientMartialBody5", 1.0},
                {"ancientMartialBody6", 1.2},
                {"ancientMartialBody7", 0.95},
                {"ancientMartialBody8", 1.5},
                {"ancientMartialBody9", 0.9},
                {"ancientMartialBody91", 1.8},
                {"ancientMartialBody92", 1.1},
                {"ancientMartialBody93", 1.2},
                {"ancientMartialBody94", 0.95},
                {"ancientMartialBody95", 1.0},
                {"ancientMartialBody96", 1.2},
                {"ancientMartialBody97", 0.99},
                {"ancientMartialBody98", 1.25},
                {"ancientMartialBody99", 1.3}
            };
    
            // 检查所有荒古武躯特质并应用修正
            foreach (var trait in ancientBodyModifiers.Keys)
            {
                if (a.hasTrait(trait))
                {
                    successRate *= ancientBodyModifiers[trait];
                }
            }

            // 检查是否有邪功特质，如果有则降低成功率为原先的五分之四
            if (a.hasTrait("EvilGongFa1") || a.hasTrait("EvilGongFa2") || a.hasTrait("EvilGongFa3"))
            {
                successRate *= 0.8;
            }

            if (UnityEngine.Random.Range(0.0f, 1.0f) > successRate)
            {
                return false;
            }

            upTrait(
                "Warrior6",
                "Warrior7",
                a,
                new string[] { "tumorInfection", "cursed", "infected", "mushSpores", "Warrior6+", "martialBloodline1" },
                new string[] { "Warrior7+", "martialBloodline2", "tough" }
            );
            UpdateNameSuffix(a, "Warrior7");
            ApplyWarriorTitle(a, "Warrior7");

            string[] GongFa = { "GongFaTrait1", "GongFaTrait2", "GongFaTrait3", "GongFaTrait4", "GongFaTrait5", "GongFaTrait6", "GongFaTrait7", "GongFaTrait8", "GongFaTrait9", "GongFaTrait10", "GongFaTrait11", "GongFaTrait12", "GongFaTrait13", "GongFaTrait14", "EvilGongFa1" };
            int randomIndex2 = UnityEngine.Random.Range(0, GongFa.Length);
            string selectedGongFa = GongFa[randomIndex2];
            a.addTrait(selectedGongFa);

            if (!a.hasTrait("congenitalPerfection") && 
                !a.hasTrait("ancientMartialBody1") && 
                Randy.randomChance(0.2f))
            {
                a.addTrait("Warrior94", false);
            }
            TryAddSpiritualPlant(a, "Warrior7");

            return true;
        }

        public static bool Warrior8_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            if (WarriorConfig.LimitWarrior8)
            {
                return false;
            }
            if (a.GetWarrior() <294) // 衰退阈值
            {
                upTrait("Warrior7", "Warrior6", a, 
                    new[] { "Warrior7+", "tough" }, // 移除洞虚境特质
                    new[] { "Warrior6+", "fire_proof" }); // 添加凝罡境特质
                return true;
            }
            if (a.GetWarrior() <= 499.99)
            {
                return false;
            }

            a.ChangeWarrior(-9);
            double successRate = 0.08;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.004;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.008;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.02;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.1;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 0.4;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 0.8;
            }

            var ancientBodyModifiers = new Dictionary<string, double>
            {
                {"ancientMartialBody1", 0.88},
                {"ancientMartialBody2", 1.2},
                {"ancientMartialBody3", 2.0},
                {"ancientMartialBody4", 1.25},
                {"ancientMartialBody5", 1.0},
                {"ancientMartialBody6", 1.2},
                {"ancientMartialBody7", 0.95},
                {"ancientMartialBody8", 1.5},
                {"ancientMartialBody9", 0.9},
                {"ancientMartialBody91", 1.8},
                {"ancientMartialBody92", 1.1},
                {"ancientMartialBody93", 1.2},
                {"ancientMartialBody94", 0.95},
                {"ancientMartialBody95", 1.0},
                {"ancientMartialBody96", 1.2},
                {"ancientMartialBody97", 0.99},
                {"ancientMartialBody98", 1.25},
                {"ancientMartialBody99", 1.3}
            };
    
            // 检查所有荒古武躯特质并应用修正
            foreach (var trait in ancientBodyModifiers.Keys)
            {
                if (a.hasTrait(trait))
                {
                    successRate *= ancientBodyModifiers[trait];
                }
            }

            // 检查是否拥有混沌帝血特质，如果有则成功率翻倍
            if (a.hasTrait("martialBloodline7"))
            {
                successRate *= 2.0;
            }

            // 检查是否拥有武道六难特质，如果有则成功率减半
            string[] martialDifficulties = { "Warrior94"};
            foreach (string difficulty in martialDifficulties)
            {
                if (a.hasTrait(difficulty))
                {
                    successRate /= 2;
                    break;
                }
            }

            // 检查是否有邪功特质，如果有则降低成功率为原先的五分之四
            if (a.hasTrait("EvilGongFa1") || a.hasTrait("EvilGongFa2") || a.hasTrait("EvilGongFa3"))
            {
                successRate *= 0.7;
            }

            if (UnityEngine.Random.Range(0.0f, 1.0f) > successRate)
            {
                return false;
            }

            upTrait(
                "Warrior7",
                "Warrior8",
                a,
                new string[] { "tumorInfection", "cursed", "infected", "mushSpores", "Warrior7+", "Warrior94", "martialBloodline2" },
                new string[] { "Warrior8+", "strong_minded", "immune", "martialBloodline3" }
            );
            UpdateNameSuffix(a, "Warrior8");

            if (!a.hasTrait("congenitalPerfection") && 
                !a.hasTrait("ancientMartialBody1") && 
                Randy.randomChance(0.2f))
            {
                a.addTrait("Warrior95", false);
            }

            bool hasAnyAncientMartialBody = 
                a.hasTrait("ancientMartialBody1") ||
                a.hasTrait("ancientMartialBody2") ||
                a.hasTrait("ancientMartialBody3") ||
                a.hasTrait("ancientMartialBody4") ||
                a.hasTrait("ancientMartialBody5") ||
                a.hasTrait("ancientMartialBody6") ||
                a.hasTrait("ancientMartialBody7") ||
                a.hasTrait("ancientMartialBody8") ||
                a.hasTrait("ancientMartialBody9") ||
                a.hasTrait("ancientMartialBody91") ||
                a.hasTrait("ancientMartialBody92") ||
                a.hasTrait("ancientMartialBody93") ||
                a.hasTrait("ancientMartialBody94") ||
                a.hasTrait("ancientMartialBody95") ||
                a.hasTrait("ancientMartialBody96") ||
                a.hasTrait("ancientMartialBody97") ||
                a.hasTrait("ancientMartialBody98") ||
                a.hasTrait("ancientMartialBody99");
            
            string selectedTrait = null; // 在外部声明变量

            if (!hasAnyAncientMartialBody && UnityEngine.Random.Range(0f, 1f) < 0.006f)
            {
                string[] ancientMartialBodies = {
                    "ancientMartialBody1",
                    "ancientMartialBody2",
                    "ancientMartialBody3",
                    "ancientMartialBody4",
                    "ancientMartialBody5",
                    "ancientMartialBody6",
                    "ancientMartialBody7",
                    "ancientMartialBody8",
                    "ancientMartialBody9",
                    "ancientMartialBody91",
                    "ancientMartialBody92",
                    "ancientMartialBody93",
                    "ancientMartialBody94",
                    "ancientMartialBody95",
                    "ancientMartialBody96",
                    "ancientMartialBody97",
                    "ancientMartialBody98",
                    "ancientMartialBody99"
                };
        
                selectedTrait = ancientMartialBodies[UnityEngine.Random.Range(0, ancientMartialBodies.Length)]; // 赋值
                a.addTrait(selectedTrait, false);
                if (selectedTrait == "ancientMartialBody1" || 
                    selectedTrait == "ancientMartialBody4" || 
                    selectedTrait == "ancientMartialBody91" ||
                    selectedTrait == "ancientMartialBody96" ||
                    selectedTrait == "ancientMartialBody9")
                {
                    a.data.favorite = true;
                }
            }

            // 显示觉醒通知
            if (selectedTrait != null) 
            {
                NotificationHelper.ShowMartialBodyNotification(a, selectedTrait);
            }
            TryAddSpiritualPlant(a, "Warrior8");

            return true;
        }

        public static bool Warrior9_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            if (WarriorConfig.LimitWarrior9)
            {
                return false;
            }
            if (a.GetWarrior() < 491)
            {
                upTrait("Warrior8", "Warrior7", a, 
                    new[] { "Warrior8+", "strong_minded" },
                    new[] { "Warrior7+", "tough" });
                return true;
            }
            if (a.GetWarrior() <= 799.99)
            {
                return false;
            }

            a.ChangeWarrior(-15);
            double successRate = 0.08;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.005;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.02;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.05; 
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.1;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 0.4;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 0.8;
            }

            var ancientBodyModifiers = new Dictionary<string, double>
            {
                {"ancientMartialBody1", 0.88},
                {"ancientMartialBody2", 1.2},
                {"ancientMartialBody3", 2.0},
                {"ancientMartialBody4", 1.25},
                {"ancientMartialBody5", 1.0},
                {"ancientMartialBody6", 1.2},
                {"ancientMartialBody7", 0.95},
                {"ancientMartialBody8", 1.5},
                {"ancientMartialBody9", 0.9}
            };
    
            // 检查所有荒古武躯特质并应用修正
            foreach (var trait in ancientBodyModifiers.Keys)
            {
                if (a.hasTrait(trait))
                {
                    successRate *= ancientBodyModifiers[trait];
                }
            }

            // 检查是否拥有混沌帝血特质，如果有则成功率翻倍
            if (a.hasTrait("martialBloodline7"))
            {
                successRate *= 2.0;
            }

            // 检查是否拥有武道六难特质，如果有则成功率减半
            string[] martialDifficulties = { "Warrior95" };
            foreach (string difficulty in martialDifficulties)
            {
                if (a.hasTrait(difficulty))
                {
                    successRate /= 2;
                    break;
                }
            }

            // 检查是否有邪功特质，如果有则降低成功率为原先的五分之四
            if (a.hasTrait("EvilGongFa1") || a.hasTrait("EvilGongFa2") || a.hasTrait("EvilGongFa3"))
            {
                successRate *= 0.7;
            }

            if (UnityEngine.Random.Range(0.0f, 1.0f) > successRate)
            {
                return false;
            }

            upTrait(
                "Warrior8",
                "Warrior9",
                a,
                new string[] { "tumorInfection", "cursed", "infected", "mushSpores", "Warrior8+", "Warrior95", "martialBloodline3" },
                new string[] { "Warrior9+" ,"fire_proof", "regeneration", "martialBloodline4"}
            );
            UpdateNameSuffix(a, "Warrior9");
            ApplyWarriorTitle(a, "Warrior9");
       
            if (!a.hasTrait("congenitalPerfection") && 
                !a.hasTrait("ancientMartialBody1") && 
                Randy.randomChance(0.2f))
            {
                a.addTrait("Warrior96", false);
            }
            TryAddSpiritualPlant(a, "Warrior9");

            return true;
        }

        public static bool Warrior91_effectAction(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            if (WarriorConfig.BreakthroughLimit)
            {
                return false;
            }
            if (a.GetWarrior() <= 1199.99)
            {
                return false;
            }

            a.ChangeWarrior(-50);
            double successRate = 0.08;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.003;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.006;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.015;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.08;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 0.15;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 0.3;
            }

            var ancientBodyModifiers = new Dictionary<string, double>
            {
                {"ancientMartialBody1", 0.88},
                {"ancientMartialBody2", 1.2},
                {"ancientMartialBody3", 2.0},
                {"ancientMartialBody4", 1.25},
                {"ancientMartialBody5", 1.0},
                {"ancientMartialBody6", 1.2},
                {"ancientMartialBody7", 0.95},
                {"ancientMartialBody8", 1.5},
                {"ancientMartialBody9", 0.9},
                {"ancientMartialBody91", 1.8},
                {"ancientMartialBody92", 1.1},
                {"ancientMartialBody93", 1.2},
                {"ancientMartialBody94", 0.95},
                {"ancientMartialBody95", 1.0},
                {"ancientMartialBody96", 1.2},
                {"ancientMartialBody97", 0.99},
                {"ancientMartialBody98", 1.25},
                {"ancientMartialBody99", 1.3}
            };
    
            // 检查所有荒古武躯特质并应用修正
            foreach (var trait in ancientBodyModifiers.Keys)
            {
                if (a.hasTrait(trait))
                {
                    successRate *= ancientBodyModifiers[trait];
                }
            }

            // 检查是否拥有混沌帝血特质，如果有则成功率翻倍
            if (a.hasTrait("martialBloodline7"))
            {
                successRate *= 2.0;
            }

            // 检查是否拥有武道六难特质，如果有则成功率减半
            string[] martialDifficulties = { "Warrior96" };
            foreach (string difficulty in martialDifficulties)
            {
                if (a.hasTrait(difficulty))
                {
                    successRate /= 2;
                    break;
                }
            }

            // 检查是否有邪功特质，如果有则降低成功率为原先的五分之四
            if (a.hasTrait("EvilGongFa1") || a.hasTrait("EvilGongFa2") || a.hasTrait("EvilGongFa3"))
            {
                successRate *= 0.6;
            }

            if (UnityEngine.Random.Range(0.0f, 1.0f) > successRate)
            {
                return false;
            }

            upTrait(
                "Warrior9",
                "Warrior91",
                a,
                new string[] { "tumorInfection", "cursed", "infected", "mushSpores", "Warrior9+", "martialBloodline4", "Warrior96" },
                new string[] { "Warrior91+", "martialBloodline5" }
            );
            UpdateNameSuffix(a, "Warrior91");
            ApplyWarriorTitle(a, "Warrior91");
            if (WarriorConfig.AutoCollectHarmony)
            {
                a.data.favorite = true;
            }
            string[] arcaneTomes = { "arcaneTome1", "arcaneTome2", "arcaneTome3", "arcaneTome4", "arcaneTome5", "arcaneTome6", "arcaneTome7", "arcaneTome8", "arcaneTome9", "arcaneTome10", "arcaneTome11", "arcaneTome12", "arcaneTome13", "arcaneTome14", "EvilGongFa3" }; // 可以添加更多传承法特质名
            int randomIndex3 = UnityEngine.Random.Range(0, arcaneTomes.Length);
            string selectedarcaneTome = arcaneTomes[randomIndex3];
            a.addTrait(selectedarcaneTome);

            if (!a.hasTrait("congenitalPerfection") && 
                !a.hasTrait("ancientMartialBody1") && 
                Randy.randomChance(0.25f))
            {
                a.addTrait("Warrior97", false);
            }

            NotificationHelper.ShowBreakthroughNotification(a, "Warrior9", "Warrior91");
            TryAddSpiritualPlant(a, "Warrior91");

            return true;
        }

        public static bool Warrior92_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            // ==== 新增斩我境限制检查 ====
            if (WarriorConfig.LimitZhanWo)
            {
                return false; // 终止突破
            }
            if (a.GetWarrior() <= 3599.99)
            {
                return false;
            }

            a.ChangeWarrior(-100);
            double successRate = 0.06;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.002;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.005;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.01;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.05;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 0.1;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 0.2;
            }

            var ancientBodyModifiers = new Dictionary<string, double>
            {
                {"ancientMartialBody1", 0.88},
                {"ancientMartialBody2", 1.2},
                {"ancientMartialBody3", 2.0},
                {"ancientMartialBody4", 1.25},
                {"ancientMartialBody5", 1.0},
                {"ancientMartialBody6", 1.2},
                {"ancientMartialBody7", 0.95},
                {"ancientMartialBody8", 1.5},
                {"ancientMartialBody9", 0.9},
                {"ancientMartialBody91", 1.8},
                {"ancientMartialBody92", 1.1},
                {"ancientMartialBody93", 1.2},
                {"ancientMartialBody94", 0.95},
                {"ancientMartialBody95", 1.0},
                {"ancientMartialBody96", 1.2},
                {"ancientMartialBody97", 0.99},
                {"ancientMartialBody98", 1.25},
                {"ancientMartialBody99", 1.3}
            };
    
            // 检查所有荒古武躯特质并应用修正
            foreach (var trait in ancientBodyModifiers.Keys)
            {
                if (a.hasTrait(trait))
                {
                    successRate *= ancientBodyModifiers[trait];
                }
            }

            // 检查是否拥有混沌帝血特质，如果有则成功率翻倍
            if (a.hasTrait("martialBloodline7"))
            {
                successRate *= 2.0;
            }

            // 检查是否拥有武道六难特质，如果有则成功率减半
            string[] martialDifficulties = { "Warrior97" };
            foreach (string difficulty in martialDifficulties)
            {
                if (a.hasTrait(difficulty))
                {
                    successRate /= 2;
                    break;
                }
            }

            // 检查是否有邪功特质，如果有则降低成功率为原先的五分之四
            if (a.hasTrait("EvilGongFa1") || a.hasTrait("EvilGongFa2") || a.hasTrait("EvilGongFa3"))
            {
                successRate *= 0.6;
            }

            if (UnityEngine.Random.Range(0.0f, 1.0f) > successRate)
            {
                return false;
            }

            upTrait(
                "Warrior91",
                "Warrior92",
                a,
                new string[] { "tumorInfection", "cursed", "infected", "mushSpores", "Warrior91+", "martialBloodline5", "Warrior97" },
                new string[] { "Warrior92+", "martialBloodline6" }
            );
            List<string> grottoTraitIds = new List<string>
            {
                "CelestialGrotto1", "CelestialGrotto2", "CelestialGrotto3", "CelestialGrotto4",
                "CelestialGrotto5", "CelestialGrotto6", "CelestialGrotto7", "CelestialGrotto8",
                "CelestialGrotto9", "CelestialGrotto10", "CelestialGrotto11", "CelestialGrotto12",
                "CelestialGrotto13", "CelestialGrotto14", "CelestialGrotto15", "CelestialGrotto16",
                "CelestialGrotto17", "CelestialGrotto18"
            };

            // 检查是否拥有任一洞天特质
            bool hasAnyGrotto = false;
            foreach (string traitId in grottoTraitIds)
            {
                if (a.hasTrait(traitId))
                {
                    hasAnyGrotto = true;
                    break;
                }
            }

            bool hasMartialDifficulty = 
                a.hasTrait("Warrior94") || a.hasTrait("Warrior95") || 
                a.hasTrait("Warrior96") || a.hasTrait("Warrior97") || 
                a.hasTrait("Warrior98") || a.hasTrait("Warrior99");

            // 如果没有洞天特质且没有武道六难，则添加洞天特质
            if (!hasAnyGrotto && !hasMartialDifficulty)
            {
                int randomIndex = UnityEngine.Random.Range(0, grottoTraitIds.Count);
                string selectedGrottoTrait = grottoTraitIds[randomIndex];
                a.addTrait(selectedGrottoTrait);
            }

            UpdateNameSuffix(a, "Warrior92");
            ApplyWarriorTitle(a, "Warrior92");
            if (WarriorConfig.AutoCollectZhanWo)
            {
                a.data.favorite = true;
            }

            if (!a.hasTrait("congenitalPerfection") && 
                !a.hasTrait("ancientMartialBody1") && 
                Randy.randomChance(0.25f))
            {
                a.addTrait("Warrior98", false);
            }

            // 添加突破提示
            NotificationHelper.ShowBreakthroughNotification(a, "Warrior91", "Warrior92");
            // 斩我境界突破成功后，随机获得一把自定义武器
            string[] customWeapons = {
                "fen_tian_jian",      // 焚天剑
                "qing_ming_jian",     // 青冥剑
                "xuan_tie_dao",       // 玄铁刀
                "yin_she_qiang",      // 银蛇枪
                "chi_lian_jian",      // 赤练剑
                "xuan_bing_dao",      // 玄冰刀
                "jin_long_qiang",     // 金龙枪
                "zi_zhu_zhang",       // 紫珠杖
                "qing_gang_jian",     // 清 Gang 剑
                "tie_gu_shan",        // 铁枪盾
                "duan_yun_dao",       // 断云刀
                "chuan_yun_qiang",    // 穿云枪
                "xuan_tie_zhong_jian", // 玄铁中剑
                "zhui_feng_dao",      // 火风刀
                "fu_hu_gun",          // 火虎枪
                "qing_shuang_jian",   // 清双剑
                "chi_yan_dao",        // 烈焰刀
                "xuan_ying_qiang",    // 玄鹰枪
                "jin_lin_jian",       // 金龙剑
                "yin_yue_dao",         // 银月刀
                "zi_dian_qiang",       // 紫点枪
                "qing_zhu_jian",      // 清珠剑
                "chi_xue_dao",        // 赤雪刀
                "custom_sword_1",     // 自定义剑1
                "custom_sword_2",     // 自定义剑2
                "custom_sword_3",     // 自定义剑3
                "custom_sword_4",     // 自定义剑4
                "custom_sword_5",     // 自定义剑5
                "custom_sword_6",     // 自定义剑6
                "custom_sword_7",     // 自定义剑7
                "custom_sword_8",     // 自定义剑8
                "custom_sword_9",     // 自定义剑9
                "custom_sword_10",    // 自定义剑10
                "custom_sword_11",    // 断云剑
                "custom_sword_12",    // 断云剑
                "custom_sword_13",    // 穿云剑
                "custom_sword_14",    // 玄铁重剑
                "custom_sword_15",    // 追风剑
                "custom_sword_16",     // 追风剑
                "weapon_0",            // 武器0
                "weapon_1",            // 武器1
                "weapon_2",            // 武器2
                "weapon_3",            // 武器3
                "weapon_4",            // 武器4
                "weapon_5",            // 武器5
                "weapon_6",            // 武器6
                "weapon_7",            // 武器7
                "weapon_8",            // 武器8
                "weapon_9",            // 武器9
                "weapon_10",           // 武器10
                "weapon_12",            // 武器12
                "weapon_13",            // 武器13
                "weapon_14",            // 武器14
                "weapon_15",            // 武器15
                "weapon_16",            // 武器16
                "weapon_17",            // 武器17
                "weapon_96",            // 武器96
                "weapon_91",            // 武器91
                "weapon_92",            // 武器92
                "weapon_93",            // 武器93
                "weapon_94",            // 武器94
                "weapon_99",            // 武器99
                "weapon_95"             // 武器95
            };
            
            // 只有当配置开启时才发放武器
            if (WarriorConfig.AllowZhanWoWeaponAward)
            {
                // 随机选择一把武器
                int weaponIndex = UnityEngine.Random.Range(0, customWeapons.Length);
                string selectedWeapon = customWeapons[weaponIndex];
                
                // 给角色添加选中的武器（使用ActorExtensions中的扩展方法）
                a.addItem(selectedWeapon, 1);
            }

            TryAddSpiritualPlant(a, "Warrior92");

            return true;
        }

        // 不再需要本地addItem方法，使用ActorExtensions中的扩展方法

        public static bool Warrior93_effectAction(BaseSimObject pTarget, WorldTile pTile = null) 
        {
            if (pTarget == null)
            {
                return false;
            }

            if (!pTarget.isActor())
            {
                return false;
            }

            Actor a = pTarget.a;
            // ==== 新增武极境限制检查 ====
            if (WarriorConfig.LimitWuJi)
            {
                return false; // 终止突破
            }

            if (a.GetWarrior() <= 11999.99)
            {
                return false;
            }

            a.ChangeWarrior(-150);
            double successRate = 0.02;
            if (a.hasTrait("martialAptitude1"))
            {
                successRate = 0.0001;
            }
            else if (a.hasTrait("martialAptitude2"))
            {
                successRate = 0.0002;
            }
            else if (a.hasTrait("martialAptitude3"))
            {
                successRate = 0.001;
            }
            else if (a.hasTrait("martialAptitude4"))
            {
                successRate = 0.005;
            }
            else if (a.hasTrait("martialAptitude7"))
            {
                successRate = 0.015;
            }
            else if (a.hasTrait("martialAptitude8"))
            {
                successRate = 0.1;
            }

            var ancientBodyModifiers = new Dictionary<string, double>
            {
                {"ancientMartialBody1", 0.88},
                {"ancientMartialBody2", 1.2},
                {"ancientMartialBody3", 2.0},
                {"ancientMartialBody4", 1.25},
                {"ancientMartialBody5", 1.0},
                {"ancientMartialBody6", 1.2},
                {"ancientMartialBody7", 0.95},
                {"ancientMartialBody8", 1.5},
                {"ancientMartialBody9", 0.9},
                {"ancientMartialBody91", 1.8},
                {"ancientMartialBody92", 1.1},
                {"ancientMartialBody93", 1.2},
                {"ancientMartialBody94", 0.95},
                {"ancientMartialBody95", 1.0},
                {"ancientMartialBody96", 1.2},
                {"ancientMartialBody97", 0.99},
                {"ancientMartialBody98", 1.25},
                {"ancientMartialBody99", 1.3}
            };
    
            // 检查所有荒古武躯特质并应用修正
            foreach (var trait in ancientBodyModifiers.Keys)
            {
                if (a.hasTrait(trait))
                {
                    successRate *= ancientBodyModifiers[trait];
                }
            }

            // 检查是否拥有混沌帝血特质，如果有则成功率翻倍
            if (a.hasTrait("martialBloodline7"))
            {
                successRate *= 2.0;
            }

            // 检查是否拥有武道六难特质，如果有则成功率减半
            string[] martialDifficulties = { "Warrior98" };
            foreach (string difficulty in martialDifficulties)
            {
                if (a.hasTrait(difficulty))
                {
                    successRate /= 2;
                    break;
                }
            }

            // 检查是否有邪功特质，如果有则降低成功率为原先的五分之四
            if (a.hasTrait("EvilGongFa1") || a.hasTrait("EvilGongFa2") || a.hasTrait("EvilGongFa3"))
            {
                successRate *= 0.5;
            }

            if (UnityEngine.Random.Range(0.0f, 1.0f) > successRate)
            {
                return false;
            }

            upTrait(
                "Warrior92",
                "Warrior93",
                a,
                new string[] { "tumorInfection", "cursed", "infected", "mushSpores", "Warrior92+", "martialBloodline6", "Warrior98" },
                new string[] { "Warrior93+", "immunity", "martialBloodline7" }
            );
            UpdateNameSuffix(a, "Warrior93");
            ApplyWarriorTitle(a, "Warrior93");
            if (WarriorConfig.AutoCollectWuJi)
            {
                a.data.favorite = true;
            }

            if (!a.hasTrait("ancientMartialBody1") && 
                Randy.randomChance(0.25f))
            {
                a.addTrait("Warrior99", false);
            }

            NotificationHelper.ShowBreakthroughNotification(a, "Warrior92", "Warrior93");
            
            // 随机获得一到三个九字秘特质
            string[] nineCharacterSecrets = { "NineCharacterSecret1", "NineCharacterSecret2", "NineCharacterSecret3", "NineCharacterSecret4", "NineCharacterSecret5", "NineCharacterSecret6", "NineCharacterSecret7", "NineCharacterSecret8", "NineCharacterSecret9" };
            int traitCount = UnityEngine.Random.Range(1, 4);
            List<string> selectedTraits = new List<string>();

            while (selectedTraits.Count < traitCount)
            {
                int randomIndex = UnityEngine.Random.Range(0, nineCharacterSecrets.Length);
                string selectedTrait = nineCharacterSecrets[randomIndex];
                if (!selectedTraits.Contains(selectedTrait))
                {
                    selectedTraits.Add(selectedTrait);
                    a.addTrait(selectedTrait);
                }
            }
            TryAddSpiritualPlant(a, "Warrior93");

            return true;
        }

        //阵师的恢复生命值效果
        public static bool FormationRealm1_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float patternValue = actor.GetPattern();
                int healAmount = Mathf.RoundToInt(patternValue * 0.5f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        
        // 第二重境界阵师的恢复生命值效果
        public static bool FormationRealm2_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            if (actor.data.health <= 0) 
            {
                actor.batch.c_check_deaths.Add(actor);
                return false;
            }
    
            if (actor.data.health < actor.getMaxHealth())
            {
                float patternValue = actor.GetPattern();
                int healAmount = Mathf.RoundToInt(patternValue * 1.2f);
        
                healAmount = Mathf.Max(2, healAmount);
        
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        
        // 第三重境界阵师的恢复生命值效果
        public static bool FormationRealm3_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            if (actor.data.health <= 0) 
            {
                actor.batch.c_check_deaths.Add(actor);
                return false;
            }
    
            if (actor.data.health < actor.getMaxHealth())
            {
                float patternValue = actor.GetPattern();
                int healAmount = Mathf.RoundToInt(patternValue * 2.0f);
        
                healAmount = Mathf.Max(3, healAmount);
        
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        
        // 第四重境界阵师的恢复生命值效果
        public static bool FormationRealm4_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            if (actor.data.health <= 0) 
            {
                actor.batch.c_check_deaths.Add(actor);
                return false;
            }
    
            if (actor.data.health < actor.getMaxHealth())
            {
                float patternValue = actor.GetPattern();
                int healAmount = Mathf.RoundToInt(patternValue * 3.6f);
        
                healAmount = Mathf.Max(5, healAmount);
        
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        
        // 第五重境界阵师的恢复生命值效果
        public static bool FormationRealm5_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            if (actor.data.health <= 0) 
            {
                actor.batch.c_check_deaths.Add(actor);
                return false;
            }
    
            if (actor.data.health < actor.getMaxHealth())
            {
                float patternValue = actor.GetPattern();
                int healAmount = Mathf.RoundToInt(patternValue * 8.0f);
        
                healAmount = Mathf.Max(8, healAmount);
        
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        
        // 第六重境界阵师的恢复生命值效果
        public static bool FormationRealm6_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            if (actor.data.health <= 0) 
            {
                actor.batch.c_check_deaths.Add(actor);
                return false;
            }
    
            if (actor.data.health < actor.getMaxHealth())
            {
                float patternValue = actor.GetPattern();
                int healAmount = Mathf.RoundToInt(patternValue * 12f);
        
                healAmount = Mathf.Max(15, healAmount);
        
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        
        //武者的恢复生命值效果
        public static bool Warrior1_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.1f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior2_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.2f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior3_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.3f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior4_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.4f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior5_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.5f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior6_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.6f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior7_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.7f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior8_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.8f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior9_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.9f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior91_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 1.0f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior92_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 1.1f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool Warrior93_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 1.2f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool NineCharacterSecret3_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.3f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        public static bool NineCharacterSecret6_Regen(BaseSimObject pTarget, WorldTile pTile = null)
        {
            if (pTarget == null || !pTarget.isActor()) 
                return false;

            Actor actor = pTarget.a;
    
            // 关键修改：添加死亡状态检查
            if (actor.data.health <= 0) 
            {
                // 确保触发死亡流程
                actor.batch.c_check_deaths.Add(actor);
                return false; // 死亡状态下不执行回血
            }
    
            // 仅在生命值低于最大值时回血
            if (actor.data.health < actor.getMaxHealth())
            {
                float warriorValue = actor.GetWarrior();
                int healAmount = Mathf.RoundToInt(warriorValue * 0.5f);
        
                // 确保至少回复1点生命
                healAmount = Mathf.Max(1, healAmount);
        
                // 关键修改：防止回血超过最大生命值
                int actualHeal = Mathf.Min(healAmount, actor.getMaxHealth() - actor.data.health);
        
                actor.restoreHealth(actualHeal);
                actor.spawnParticle(Toolbox.color_heal);
            }
            return true;
        }
        /// <summary>
        ///
        /// </summary>
        /// <param name="old_trait">升级前的特质</param>
        /// <param name="new_trait">升级到的特质</param>
        /// <param name="actor">单位传入</param>
        /// <param name="other_Oldtraits">升级要删掉的特质(不包括升级前的主特质)</param>
        /// <param name="other_newTrait">升级后要伴随添加的特质(不包含主特质)</param>
        // 更新阵道境界的名称后缀
        
        /// <returns></returns>
        public static bool upTrait(
            string old_trait,
            string new_trait,
            Actor actor,
            string[] other_Oldtraits = null,
            string[] other_newTrait = null
        )
        {
            if (actor == null)
            {
                return false;
            }

            // 安全检查：避免空引用异常
            if (other_newTrait != null)
            {
                foreach (string trait in other_newTrait)
                {
                    actor.addTrait(trait);
                }
            }

            if (other_Oldtraits != null)
            {
                foreach (var trait in other_Oldtraits)
                {
                    actor.removeTrait(trait);
                }
            }

            actor.addTrait(new_trait);
            actor.removeTrait(old_trait);

            return true;
        }
    }
}